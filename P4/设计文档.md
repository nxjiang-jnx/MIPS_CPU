# P4_MIPS单周期处理器_设计文档

在P3上机之后，我更加深刻理解了“**高内聚低耦合**”的重要指导思想，换句话说就是“**模块化、层次化**”。具体来说，决定将所有的条件跳转指令全部放在`CTRL`中，比如将`beq` 指令的`Zero` 信号不要直接接在`NPC`的外部接口，而是回传到`CTRL`中。这样不仅结构层次化更为合理，工程扩展更为容易，而且最重要的是：**对于条件跳转指令的`GRF` 写使能问题得以很好的解决。**因为`RFWr` 在`CTRL` 中使用一个与门就很好的控制了。有效避免了往届博客中说的“不满足条件的时候不link”的问题。

下面进入P4课下。本次使用`Verilog HDL`设计和P3主要有一下不同：

1. 全部改为**同步复位**。这就摆脱了`logisim`中对寄存器复位的硬件限制，可以将`PC` 直接初始化为 `0x00003000`。
2. 相比于logisim，Verilog要特别注意**初始化问题**。所有涉及存储的原件必须都要初始化。
3. `always @(*)` 块中通常使用阻塞赋值 `=`。因为是组合逻辑。
4. 加了几条与函数有关的跳转指令。总共支持的指令为：`add, sub, ori, lw, sw, beq, lui, jal, jr, nop`。

## 整体架构

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031215400531.png" alt="image-20241031215400531" style="zoom:33%;" />

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031215453564.png" alt="image-20241031215453564" style="zoom:70%;" />

## 模块的定义

### PC

| 信号名 | 方向 |                             描述                             |
| :----: | :--: | :----------------------------------------------------------: |
|  clk   |  I   |                           时钟信号                           |
| reset  |  I   | **同步复位**信号。复位值为起始地址，**起始地址：0x00003000。** |
|  NPC   |  I   |         在时钟上升沿来临时，将要更新的新PC值，32位。         |
|   PC   |  O   |                        新PC值，32位。                        |

注意，这里的PC全部都是以 `0x00003000` 为基地址，不存在像P3中的“内部消化”和“给别人看”的两个值的PC。因此，在后面的IM中就要非常注意了，因为IM的基地址是0，涉及到一个前序的减法问题。

这里注意，因为涉及到时钟的同步控制，是一个**同步逻辑时序电路**，因此不能直接用`assign` 进行`wire` 型赋值，而是**要把O端的`PC` 设置为`reg` 类型。**同时，时序逻辑记得**非阻塞赋值**。

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031211957062.png" alt="image-20241031211957062" style="zoom:50%;" />

###  IM

| 信号名 | 方向 |                    描述                    |
| :----: | :--: | :----------------------------------------: |
|   PC   |  I   | 32位PC输入。注意PC是从 `0x00003000` 开始的 |
| Instr  |  O   |                32位指令输出                |
| opcode |  O   |        `InstrMemory[Addr][31 : 26]`        |
| funct  |  O   |         `InstrMemory[Addr][5 : 0]`         |
|   rs   |  O   |        `InstrMemory[Addr][25 : 21]`        |
|   rt   |  O   |        `InstrMemory[Addr][20 : 16]`        |
|   rd   |  O   |        `InstrMemory[Addr][15 : 11]`        |
| imm16  |  O   |        `InstrMemory[Addr][15 : 0]`         |
| imm26  |  O   |        `InstrMemory[Addr][25 : 0]`         |

注意事项：

1. IM是纯**组合逻辑**。

2. 我们现在没有ROM这样的模块来存储指令了。在ISE中，我们采用 `$readmemh` 指令来将指令的十六进制码从 `code.txt` 文本文件读入到 **IM 中构造的匹配需求数量的 32 位寄存器的阵列**。使用`$readmemh("code.txt", instrumemory); `语句向内存中导入 `code.txt` 里存储的机器码，注意要将这个文件通过`Add source`的方式加入到ISE左侧的Project列表里；同时，这个操作应当通过`initial`块实现。
3. IM 容量为 16KiB（4096 × 32bit）。
4. 要避免ISE/VCS差异带来的影响，按**从低到高的范围声明存储器的数量**，例如 `reg [31 : 0] InstrMemory [0 : 4095];`
5. PC中说了，现在传进来的PC是真PC，需要先减去 `0x00003000`，再右移2位，再截取低12位才是对应的IM中的地址。可以定义一个`wire` 类型的地址变量：`wire [11 : 0] Addr; assign Addr = (PC - 32'h00003000) >> 2;` 这是最需要注意的部分。
6. 非常注意！`wire` **不能直接赋值**！`wire [11 : 0] Addr = (PC - 32'h00003000) >> 2;`的写法是**错误的**！
7. **强烈建议将得到的指令在IM中按字段分好**。

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031212020828.png" alt="image-20241031212020828" style="zoom:50%;" />

### GRF

![image-20241030150624075](E:\myFolder_3\COLab\P4\assets\image-20241030150624075.png)

注意事项：

1. 始终保证0号寄存器**不能被写入**且**读出永远为0**。因此**写入**时要判断，且**额外判断**0号寄存器的输出。
2. 注意用 `initial` 块帮所有寄存器初始化为0。一定要养成**对所有存储记忆部件进行 `initial` 操作**的好习惯。
3. `initial` 中采用**阻塞赋值** `=` 。
4. **写入**是同步**时序**逻辑。**输出**是纯**组合**逻辑，使用 `assign` 。 `assign` 本身也不能放在`always` 模块中。

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031212733591.png" alt="image-20241031212733591" style="zoom:80%;" />

### DM

| 信号名 | 方向 |                描述                 |
| :----: | :--: | :---------------------------------: |
|  clk   |  I   |              时钟信号               |
| reset  |  I   |  异步复位信号。复位值为 0x00000000  |
|   A    |  I   |            32位地址输入             |
|   WD   |  I   |            32位写入数据             |
|  DMWr  |  I   | 写使能端，当为1时，从输入端存入数据 |
|   RD   |  O   |            32位数据输出             |

注意事项：

1. DM 容量为 12KiB（3072 × 32bit）。因此，地址位宽为12.
2. 截取位宽的时候要注意。我才用输入地址为32位，而定位的地址在DM内部进行消化，达到“高内聚低耦合”的效果。因此，这涉及到**右移2位后截取低12位**。方法是在内部定义一个新的地址变量 `wire [11 : 0] addr = A >> 2;` 这和IM中的设计思路完全一致。
3. 值得一提的是，`wire [11 : 0] addr; assign addr = A >> 2;` 和`wire [11:0] addr; assign addr = A[13:2];` 是**等价的**，因为Verilog会**自动截取**。而`wire [13:2] addr = A[13:2];`这种写法是**错误的**。

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031212812286.png" alt="image-20241031212812286" style="zoom:50%;" />

### ALU

| 信号名 | 方向 |                             描述                             |
| :----: | :--: | :----------------------------------------------------------: |
| ALUOp  |  I   | **3位**功能选择信号。 **000**：add。**001**：sub。**010**：or。**011**：lui |
|  Op1   |  I   |                        32位数据输入1                         |
|  Op2   |  I   |                        32位数据输入2                         |
| result |  O   |                         32位结果输出                         |
|  Zero  |  O   |                   A-B==0则置为1，否则置0.                    |

注意事项：

1. ALU是纯**组合逻辑**。
2. 注意 `ori` 的实现：`(ALUOp == 3'b010) ? Op1 | Op2 ://ori`，注意不要误写成`Op1 || Op2`，这实际上是一个逻辑“或”操作，返回 1 位布尔值（1 或 0），而非位宽为 32 位的**按位“或”操作**。

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031212828981.png" alt="image-20241031212828981" style="zoom:50%;" />

### NPC

| 信号名 | 方向 |                            描述                             |
| :----: | :--: | :---------------------------------------------------------: |
| NPCOp  |  I   | 2位功能选择信号。00：顺序执行；01：分支跳转；10：无条件跳转 |
|   PC   |  I   |                         32位老PC值                          |
|  Imm   |  I   |                         26位立即数                          |
|  PC4   |  O   |                           原PC+4                            |
|  NPC   |  O   |                        新的PC输出值                         |

NPC也是非常易错的原件。注意事项：

1. 分支跳转（也就是**条件跳转**）的**立即数**是**偏移量**，要将26位立即数截取低16位。NPC的值是 `PC + 4 + offset`。典型的指令是 `beq` 。无条件跳转的立即数就是地址本身。NPC的值是 `{PC[31:28], Imm, 2’b0}`。
2. 注意无论何种指令，`Imm` 都要**左移两位**再与 `PC + 4` 相加。
3. 一定注意，`Imm` 一定是**符号扩展**！

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031212912940.png" alt="image-20241031212912940" style="zoom:50%;" />

### EXT

| 信号名 | 方向 |                       描述                       |
| :----: | :--: | :----------------------------------------------: |
|   in   |  I   |                  16位立即数输入                  |
| EXTOp  |  I   | 立即数扩展功能选择。0：无符号扩展。1：符号扩展。 |
|  out   |  O   |                   32位扩展结果                   |

<img src="E:\myFolder_3\COLab\P4\assets\image-20241031212932331.png" alt="image-20241031212932331" style="zoom:50%;" />

## 数据通路分析

| 指令 | opcode | funct  | NPCOp | ALUOp | A3WRSel | WDSel | EXTOp | RFWE | ALUBSel | DMWr |
| :--: | :----: | :----: | :---: | :---: | :-----: | :---: | :---: | :--: | :-----: | :--: |
| add  | 000000 | 100000 |  00   |  000  |   01    |  00   |   X   |  1   |    0    |  X   |
| sub  | 000000 | 100010 |  00   |  001  |   01    |  00   |   X   |  1   |    0    |  X   |
| ori  | 001101 |   X    |  00   |  010  |   00    |  00   |   0   |  1   |    1    |  X   |
|  lw  | 100011 |   X    |  00   |  000  |   00    |  01   |   1   |  1   |    1    |  X   |
|  sw  | 101011 |   X    |  00   |  000  |    X    |   X   |   1   |  X   |    1    |  1   |
| beq  | 000100 |   X    |  01   |  001  |    X    |   X   |   X   |  X   |    0    |  X   |
| lui  | 001111 |   X    |  00   |  011  |   00    |  00   |   0   |  1   |    1    |  X   |
| nop  | 000000 | 000000 |  00   |   X   |    X    |   X   |   X   |  X   |    X    |  X   |
| jal  | 000011 |   X    |  10   |   X   |   10    |  10   |   X   |  1   |    X    |  X   |
|  jr  | 000000 | 001000 |  11   |   X   |    X    |   X   |   X   |  X   |    X    |  X   |

## 总线外观

![image-20241031213017205](E:\myFolder_3\COLab\P4\assets\image-20241031213017205.png)

参考了课本上的设计：

![image-20241031213104060](E:\myFolder_3\COLab\P4\assets\image-20241031213104060.png)

## 易错注意事项

1. 注意接线。课下debug中，在顶层接线时，发现database忘记将`Zero` **放置在模块端口**中，导致`Zero` 在控制信号中未被驱动。
1. 注意`for` 循环必须要放在`always@(*)` 中。同时计数器必须要`reg ` 类型，而且要注意**位宽**！还要在`always@(*)` 中**初始化**！
1. 千万不要出现“`wire` 型直接赋值” 的错误。例如，一定要拆开成`assign` ：

```verilog
wire senodb;
assign senodb = (senodbYes) ? 1'b1 : 1'b0;
```

4. 注意**位宽**！`rs`、`rt`、`rd` 都是5位的，所以是 `[4:0]` ！
5. 注意`Datapath` 中的`opcode` 、`funct`、`Zero` 都应该是`output`！后续添加的任何条件跳转指示信号也应该是 `output`。而这三个信号恰好在`CTRL` 里边是 `input` ！正好**耦合在了一起**！一开始把`Datapath` 中所有信号都写成了 `input` ，就导致了某些信号 `no driver` 的情况！！！
6. 对于条件跳转指令，通常要增加一个**判断信号**。注意千万不要只在 `CTRL` 和 `database` 里边加了相互耦合的判断信号（根`Zero` 是同类的），**一定要记得**在顶层 `mips.v` 里边**加上一根导线，把二者串起来**！！！P4当时就因为这个卡了一会！！！

## 思考题汇总

1. 阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？

   ![66.png](http://cscore.buaa.edu.cn/assets/cscore-image/refkxh/86953c72-c519-48b2-8cb8-7b2c90850e53/66.png)

   答：这个addr信号是从ALU计算输出而来的。因为ALU计算后的地址是**按照字节**进行存储，而DM、IM等存储元件中的数据均是32位的，是**按字存储**，因此按照字节存储定位的地址转换为按字存储的地址需要**右移2位**，也就是除以4。

   

2. 思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。

​	答：可以记录下 **指令对应的控制信号如何取值**，也就是我采用的方式：

```verilog
assign DMWr = (sw) ? 1'b1 : 1'b0;
```

​	也可以记录下**控制信号每种取值所对应的指令**：

```verilog 
assign sw = (opcode == 6'b101011 && NPCOp == 2'b00 && ......) 
```

个人认为记录 **指令对应的控制信号如何取值**更为清晰直观，因为对应着 logisim 中的与阵列和或阵列电路图。



3. 在相应的部件中，复位信号的设计都是**同步复位**，这与 P3 中的设计要求不同。请对比**同步复位**与**异步复位**这两种方式的 reset 信号与 clk 信号优先级的关系。

答：**同步**复位：**clk优先级更高**。**异步**复位：clk和reset优先级**一样高**。



4. C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。

答：根据 RTL 语言描述： addi 与 addiu 的区别在于当出现溢出时， addiu 忽略溢出，并将溢出的最高位舍弃； addi 会报告 `SignalException(IntegerOverflow) `，故忽略溢出，二者等价。

## 测试用例

```verilog
    .data               # 数据段开始
array:  .word 10, 20, 30, 40  # 定义一个数组（位于数据存储器 DM 中）

    .text               # 指令段开始
    .globl main

main:
    # 1. 测试 lui 和 ori 指令
    lui   $1, 0x1234         # $1 = 0x12340000
    ori   $1, $1, 0x5678     # $1 = 0x12345678

    # 2. 测试 add 和 sub 指令
    add   $2, $1, $1         # $2 = $1 + $1 = 0x2468ACF0
    sub   $3, $2, $1         # $3 = $2 - $1 = 0x12345678

    # 3. 测试内存加载 lw 和存储 sw
    lui   $4, 0x1000         # 将数据段基址加载到 $4 中 ($4 = 0x10000000)
    lw    $5, array($4)      # 加载 array[0]（10）到 $5 中
    lw    $6, 4($4)          # 加载 array[1]（20）到 $6 中
    add   $7, $5, $6         # $7 = 10 + 20 = 30
    sw    $7, 8($4)          # 将 $7 的值存储到 array[2]

    # 4. 测试条件分支 beq 和无条件跳转 jal
    beq   $5, $6, skip       # 如果 $5 == $6 则跳转（不跳转）
    jal   function           # 调用 function

skip:
    # 5. 测试条件分支 beq (跳转成功)
    beq   $5, $5, label1     # 因 $5 == $5，跳转到 label1

    nop                      # 占位指令

label1:
    add   $8, $0, $7         # $8 = $7（测试跳转到此处的效果）
    
    # 6. 测试 jal 和 jr 实现函数调用
    jal   func_return_test   # 跳转并链接到 func_return_test
    nop                      # 占位

exit: 
    nop                      # 结束程序

# function 子程序
function:
    add   $9, $1, $2         # $9 = $1 + $2
    jr    $31                # 返回 main

# func_return_test 子程序测试 jal 和 jr 的组合
func_return_test:
    add   $10, $9, $3        # $10 = $9 + $3
    jr    $31                # 返回 main
```

