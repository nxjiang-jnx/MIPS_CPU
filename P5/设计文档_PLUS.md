# P5_MIPS单周期处理器（支持异常处理）_设计文档

这周我们拿到的的任务是在P4的基础上新增单周期**异常的处理**。首先，我们要知道我们处理的异常涵盖哪些。

## 分析与构造

| **异常码** | **助记符与名称**        | 指令与指令类型 | **描述**                                                     |
| :--------- | :---------------------- | :------------- | :----------------------------------------------------------- |
| 4          | `AdEL` （**取指**异常） | 所有指令       | PC 地址未字对齐。/PC 地址不在 `0x3000 ~ 0x6ffc`范围内。      |
| 4          | `AdEL` （**取数**异常） | lw             | 取数地址没有字对齐。/计算地址时加法溢出 。/取数地址超出`0x0000 ~ 0x2fff`。 |
| 5          | `AdES` （**存数**异常） | sw             | 存数地址没有字对齐。/计算地址时加法溢出。/存数地址超出`0x0000 ~ 0x2fff`。 |
| 8          | `Syscall` （系统调用）  | syscall        | 系统调用。                                                   |
| 10         | `RI`（未知指令）        | -              | 未知的指令码。                                               |
| 12         | `overflow`（溢出异常）  | add, sub       | 算术溢出。                                                   |

在开始之前，有以下几点明确：

1. 任务是**纯异常**，而不涉及中断。因此，受害指令需要按照同步逻辑执行完，而不是异步中断；`EPC`返回的是受害`PC`本身，而不是`PC+4`.
2. 只需要识别异常，不需要`display`出是何种异常；但是`CAUSE` 寄存器中需要**保存**异常的编码。
3. **不需要**写异常处理程序。只需要支持几种指令即可。
4. 异常时，**当前指令不执行**！当作`nop`处理。
5. 因此，设计的“处理”仅包括：识别异常；`PC`跳转到`0x4180`；根据异常类型存储`CAUSE` 寄存器；支持几条直接对CP0内部寄存器访存的指令。

为了实现异常的识别和处理，核心就是新增了一个**协处理器**CP0。指导书中告诉我们只需要实现内部的三个寄存器：`SR` 、`CAUSE `和 `EPC`。其中在异常自发产生时（不考虑主动的`mfc0`、`mtc0`等指令，）用处如下：`SR[1]`当作 `EXL` 使用，防止重入；`CAUSE `存储异常编码，也就是上标所示的编码；`EPC `存储受害`PC` ，也就是要返回的`PC` 。

在首次看到指导书时，我对于CP0如此多的端口感到较为茫然。非常希望能够有先知者带我分析一下这些端口分别是为了**实现什么功能**，**应该和原有的数据通路如何相连**。因此首先详细明确一下CP0的输入输出端口和其分别的功能。

| **端口**  | **方向** | **位数** |                           **解释**                           |
| :-------: | :------: | :------: | :----------------------------------------------------------: |
|    clk    |    IN    |    1     |                   时钟信号。同步时序逻辑。                   |
|   reset   |    IN    |    1     |    复位信号。复位时，内部三个寄存器全部清零，`Req` 归零。    |
|    en     |    IN    |    1     | 写使能信号。指的是CP0内部上述三个寄存器的写使能。有一个写使能的目的是支持`mfc0`、`mtc0`这两条指令，这两条指令的目的是对CP0内部上述三个寄存器进行读写。可以认为，这两条指令在行为上与针对DM进行读写的`lw` 、`sw` 指令没有区别。 |
|  CP0Add   |    IN    |    5     | 寄存器地址。目的是支持`mfc0`、`mtc0`这两条指令。根据RTL描述，这两条指令均是对`CP0[rd]`进行读写操作。因此，肯定要有一个地址定位端口。而且这个端口正是要连着`rd` 。要注意，因为我们内部只实现了3个寄存器，所以该端口定位的地址只能是12、13、14，也就是三个寄存器的编码。 |
|   CP0In   |    IN    |    32    | CP0 写入数据。目的是支持`mtc0`这条写入指令。阅读RTL语言，可以知道应该与 `R[rt]` 相连。 |
|  CP0Out   |   OUT    |    32    | CP0 读出数据。目的是支持`mfc0`这条读出指令。阅读RTL语言，可以知道应该与 `R[rt]` 相连。 |
|    VPC    |    IN    |    32    |      受害` PC`。注意就是当前出现异常的指令对应的`PC`。       |
| ExcCodeIn |    IN    |    5     | 记录异常类型。异常类型就是开头表格中的那几种类型。要根据异常类型来判断一一映射的值是多少。那么问题来了，应该在哪里识别和判断异常类型呢？ |
|  EXLClr   |    IN    |    1     |                        用来复位 EXL。                        |
|  EPCOut   |   OUT    |    32    |                          EPC 的值。                          |
|    Req    |   OUT    |    1     | 进入处理程序请求。这是一个输出端口，目的是告知异常发生，让`PC` 跳转到`0x4180` 。 |

经过上述**分析**，我们建立起如下**构造**：

1. 要时刻按照“**高内聚低耦合**”的**模块化层次化**方法继续构造，形成良好的结构。可能发生自发异常的部件有：PC、ALU、DM。我们分别在这三个部件内部检测相应的异常就好了，然后分别新增**输出端口**输出**是否**发生异常。
2. 先站在微观的角度分析各个部件。在阅读指导书后很快就会发现有一个问题：**问题出现在DM可能会发生两个异常**，分别是**取数**异常 `DM_AdEL` 和**存数**异常 `AdES` 。但是这两个异常的描述中都有“**计算地址时加法溢出**”这一句话。但前面的ALU把加法地址溢出传给当前DM的时候，如果溢出，应该报哪个异常？答案呼之欲出了，要根据当前执行的指令是 `lw` 还是`sw`来确定。因此，开头的表格“**指令与指令类型**”那一栏是非常重要的。那站在DM元件的角度，如何知道当前执行的是 `lw` 还是`sw`指令？可以将异常信号传回到控制器中判断。
3. 然后站在宏观的角度考虑。现在各个部件的异常输出端口都加好了。应该把线连给谁？一个正常的思路是**直接**把线传给CP0的`ExcCodeIn` 端口。具体的做法是在最顶层加一个**多路选择器**，就像GRF的写地址或者写数据那里**一样的层级**。把异常的线全部接到这个多路选择器这里，然后**多选一**把`ExcCodeIn` 的值确定。这样真的可以吗？**这导致了我提交之后一个很严重的bug**。这样主要有**以下两个问题**：
   - 第一，开头的表格“**指令与指令类型**”那一栏是非常重要的。这导致了如果当前**不是在执行某条指令**，那该指令**特定的异常**发生时还是会被跳转到`0x4180`，而我希望是**正常执行**。最直观的例子是，如果我不是在 `lw` 或`sw`，而ALU计算出的结果超出了取数地址或存数地址（`0x0000 ~ 0x2fff`），那我就异常了 ，这显然是不合理的！因此应该在某个地方有个“**与**”，必须要当前**是在执行**某条指令**且**该指令**特定的**异常发生时才是**真正发生了异常**。否则不应该跳转走。
   - 第二，如果把这个“**与**”也拿到最高层级来做的话，**严重违背了“高内聚低耦合”的层次化原则**。因为如果这样，首先，要把CTRL控制器中增加两个识别`Syscall`和未知指令的输出端口。其次，还要在多路选择器这个层级把许多指令的判断连过来，其中不乏有需要在控制器中输出的。控制器就会徒增很多判断是哪个指令的输出，严重增加CPU的**耦合度**。不利于构造，也丧失了控制器的意义。

4. 因此，我们选择**将所有外部判断的异常全部接回控制器**。这样可以将“**与**”的逻辑在控制器中实现，大大降低耦合度。并且 `Syscall` 、`RI` 等异常就是在控制器内部实现，有利于控制器进行**内部消化**。

5. 另外一个非常体现“**高内聚低耦合**”思想的地方是`Req` 接给谁。`Req` 的功能是为1时，跳转到`0x4180` 。一个思路是给PC的输入端，把`0x4180` 和NPC的输出端加一个**二选一**连到PC的输入端。这又违背了高内聚低耦合的思想。推荐的做法是把`Req` 接回到控制器中。然后通过控制器对`NPCOp`的选择来判断NPC是什么。这也遵循了高老板“**NPC是唯一知道应该如何计算PC次地址的功能部件**” 的圣旨（《计算机组成与实现》，高老板，P129） 。

6. 那么总结一下NPC现在有几种选择了呢：

   - 000：顺序执行。
   - 001：PC+4+偏移。用于支持 `beq` 这种条件跳转。
   - 010：立即数扩展。用于支持`j`型无条件跳转。
   - 011：RA。用于支持`jr` ，从`$31` 中读出。
   - 100：EPCOut。用于支持 `eret` ，返回现场。
   - 101：`0x4180` 。

   可见把`NPCOp`设置成3位多么重要！

   

现在总结：**原有**的涉及到可能发生异常的元件进行**端口修改**。按照上述分析，涉及的添加如下汇总：

1. PC添加一个`PC_AdEL` **输出**端口。记录是否：PC 地址未字对齐。/PC 地址不在 `0x3000 ~ 0x6ffc`范围内。
2. ALU添加一个`overflow` **输出**端口。输出是否溢出。
3. DM增加一个`overflow` **输入**端口，用于获取ALU中的加法溢出。
4. DM增加一个`DM_AdEL` 输出端口。记录是否：`lw` 指令**取数**地址没有字对齐。/计算地址时加法溢出 。/取数地址超出`0x0000 ~ 0x2fff`。
5. DM增加一个`AdES` 输出端口。记录是否：`sw` 指令**存数**地址没有字对齐。/计算地址时加法溢出。/存数地址超出`0x0000 ~ 0x2fff`。
6. CTRL控制器中添加一个`EXLClr` 输出端口，作为`eret` 执行标志。
7. CTRL控制器中添加一个`Req` 输入端口，作为识别异常的标志，根据此来更新选择 `NPCOp`。
8. NPC添加一个 `EPCOut` 输入端口。
9. `NPCOp` 位宽改为3.
10. CTRL增加一个 `rs` **输入**信号，为了区分`mtc0` 和 `mfc0` 。
11. 相应的，datapath增加一个`rs` 输出信号。
12. 直接把 `ExcCodeIn` 的驱动端连接到CTRL。这简直是**高内聚低耦合思想**的最佳应用。
13. CTRL还需要添加几个输入端：`PC_AdEL` 、`overflow` 、`DM_AdEL` 、`AdES` 。也就是6种异常全部在CTRL中内部消化！

上面就是我对本次课下实验的全部思想层面的见解。至今为止，还没有进行落地开发。下面进行实践层面的修改：

## 数据通路分析

在高老板的基础上，自行添加绘制了如下的总线外观：

![image-20241109211150294](E:\myFolder_3\COLab\P5\assets\image-20241109211150294.png)

一个参考的**数据通路**如下：

|  指令   | opcode |    funct     | NPCOp | ALUOp | A3WRSel | WDSel | EXTOp | RFWE | ALUBSel | DMWr |  en  | EXLClr |
| :-----: | :----: | :----------: | :---: | :---: | :-----: | :---: | :---: | :--: | :-----: | :--: | :--: | :----: |
|   add   | 000000 |    100000    |  000  |  000  |   01    |  00   |   X   |  1   |    0    |  X   |  X   |   X    |
|   sub   | 000000 |    100010    |  000  |  001  |   01    |  00   |   X   |  1   |    0    |  X   |  X   |   X    |
|   ori   | 001101 |      X       |  000  |  010  |   00    |  00   |   0   |  1   |    1    |  X   |  X   |   X    |
|   lw    | 100011 |      X       |  000  |  000  |   00    |  01   |   1   |  1   |    1    |  X   |  X   |   X    |
|   sw    | 101011 |      X       |  000  |  000  |    X    |   X   |   1   |  X   |    1    |  1   |  X   |   X    |
|   beq   | 000100 |      X       |  001  |  001  |    X    |   X   |   X   |  X   |    0    |  X   |  X   |   X    |
|   lui   | 001111 |      X       |  000  |  011  |   00    |  00   |   0   |  1   |    1    |  X   |  X   |   X    |
|   nop   | 000000 |    000000    |  000  |   X   |    X    |   X   |   X   |  X   |    X    |  X   |  X   |   X    |
|   jal   | 000011 |      X       |  010  |   X   |   10    |  10   |   X   |  1   |    X    |  X   |  X   |   X    |
|   jr    | 000000 |    001000    |  011  |   X   |    X    |   X   |   X   |  X   |    X    |  X   |  X   |   X    |
|  mfc0   | 010000 | **rs**:00000 |  000  |   X   |   00    |  11   |   X   |  1   |    X    |  X   |  0   |   X    |
|  mtc0   | 010000 | **rs**:00100 |  000  |   X   |    X    |   X   |   X   |  X   |    X    |  X   |  1   |   X    |
|  eret   | 010000 |    011000    |  100  |   X   |    X    |   X   |   X   |  X   |    X    |  X   |  X   |   1    |
| syscall | 000000 |    001100    |  000  |   X   |    X    |   X   |   X   |  X   |    X    |  X   |  X   |   X    |

## 模块的定义

### PC

| 信号名  | 方向 |                             描述                             |
| :-----: | :--: | :----------------------------------------------------------: |
|   clk   |  I   |                           时钟信号                           |
|  reset  |  I   | **同步复位**信号。复位值为起始地址，**起始地址：0x00003000。** |
|   NPC   |  I   |         在时钟上升沿来临时，将要更新的新PC值，32位。         |
|   PC    |  O   |                        新PC值，32位。                        |
| PC_AdEL |  O   | 下列情况置1，否则置0：PC 地址未**字对齐**。/PC 地址不在 `0x3000 ~ 0x6ffc`**范围**内。 |

###  IM

| 信号名 | 方向 |                    描述                    |
| :----: | :--: | :----------------------------------------: |
|   PC   |  I   | 32位PC输入。注意PC是从 `0x00003000` 开始的 |
| Instr  |  O   |                32位指令输出                |
| opcode |  O   |        `InstrMemory[Addr][31 : 26]`        |
| funct  |  O   |         `InstrMemory[Addr][5 : 0]`         |
|   rs   |  O   |        `InstrMemory[Addr][25 : 21]`        |
|   rt   |  O   |        `InstrMemory[Addr][20 : 16]`        |
|   rd   |  O   |        `InstrMemory[Addr][15 : 11]`        |
| imm16  |  O   |        `InstrMemory[Addr][15 : 0]`         |
| imm26  |  O   |        `InstrMemory[Addr][25 : 0]`         |

### GRF

![image-20241030150624075](E:\myFolder_3\COLab\P4\assets\image-20241030150624075.png)

### DM

|  信号名  | 方向 |                描述                 |
| :------: | :--: | :---------------------------------: |
|   clk    |  I   |              时钟信号               |
|  reset   |  I   |  异步复位信号。复位值为 0x00000000  |
|    A     |  I   |            32位地址输入             |
|    WD    |  I   |            32位写入数据             |
|   DMWr   |  I   | 写使能端，当为1时，从输入端存入数据 |
| overflow |  I   |        用于获取ALU的加法溢出        |
|    RD    |  O   |            32位数据输出             |
| DM_AdEL  |  O   |              取数异常               |
| DM_AdES  |  O   |              存数异常               |

### ALU

|  信号名  | 方向 |                             描述                             |
| :------: | :--: | :----------------------------------------------------------: |
|  ALUOp   |  I   | **3位**功能选择信号。 **000**：add。**001**：sub。**010**：or。**011**：lui |
|   Op1    |  I   |                        32位数据输入1                         |
|   Op2    |  I   |                        32位数据输入2                         |
|  result  |  O   |                         32位结果输出                         |
|   Zero   |  O   |                   A-B==0则置为1，否则置0.                    |
| overflow |  O   |                          溢出标记位                          |

注意如何检测加法/减法溢出。通过数学可以证明：

- **加法溢出**当且仅当两个数的符号位**相同**，且相加之后的符号位不等于**原数**的符号位。即：

```verilog
if (Op1[31] == Op2[31] && (result[31] != Op1[31])) begin
    overflow = 1;	//add exception
end
```

- **减法溢出**当且仅当两个数的符号位**不同**，且相减之后的符号位不等于**被减数**的符号位。即：

```verilog
if (Op1[31] != Op2[31] && (result[31] != Op1[31])) begin
    overflow = 1;	//sub exception
end
```

### NPC

| 信号名 | 方向 |                            描述                             |
| :----: | :--: | :---------------------------------------------------------: |
| NPCOp  |  I   | 2位功能选择信号。00：顺序执行；01：分支跳转；10：无条件跳转 |
|   PC   |  I   |                         32位老PC值                          |
|  Imm   |  I   |                         26位立即数                          |
|   RA   |  I   |                       31号寄存器的值                        |
| EPCOut |  I   |                         EPCOut的值                          |
|  PC4   |  O   |                           原PC+4                            |
|  NPC   |  O   |                        新的PC输出值                         |

### EXT

| 信号名 | 方向 |                       描述                       |
| :----: | :--: | :----------------------------------------------: |
|   in   |  I   |                  16位立即数输入                  |
| EXTOp  |  I   | 立即数扩展功能选择。0：无符号扩展。1：符号扩展。 |
|  out   |  O   |                   32位扩展结果                   |

## 附

![e47306f9b98d68ee604421d92530892](E:\myFolder_3\COLab\P5\assets\e47306f9b98d68ee604421d92530892.jpg)

![image-20241031213104060](E:\myFolder_3\COLab\P4\assets\image-20241031213104060.png) 

![image-20241109195347537](E:\myFolder_3\COLab\P5\assets\image-20241109195347537.png)

## 易错注意事项

1. 注意接线。课下debug中，在顶层接线时，发现database忘记将`Zero` **放置在模块端口**中，导致`Zero` 在控制信号中未被驱动。
1. 注意`for` 循环必须要放在`always@(*)` 中。同时计数器必须要`reg ` 类型，而且要注意**位宽**！还要在`always@(*)` 中**初始化**！
1. 千万不要出现“`wire` 型直接赋值” 的错误。例如，一定要拆开成`assign` ：

```verilog
wire senodb;
assign senodb = (senodbYes) ? 1'b1 : 1'b0;
```

4. 注意**正确声明位宽**！`rs`、`rt`、`rd` 都是5位的，所以是 `[4:0]` ！**不要忘记声明位宽**！
5. 注意`Datapath` 中的`opcode` 、`funct`、`Zero` 都应该是`output`！后续添加的任何条件跳转指示信号也应该是 `output`。而这三个信号恰好在`CTRL` 里边是 `input` ！正好**耦合在了一起**！一开始把`Datapath` 中所有信号都写成了 `input` ，就导致了某些信号 `no driver` 的情况！！！
6. 对于条件跳转指令，通常要增加一个**判断信号**。注意千万不要只在 `CTRL` 和 `database` 里边加了相互耦合的判断信号（根`Zero` 是同类的），**一定要记得**在顶层 `mips.v` 里边**加上一根导线，把二者串起来**！！！P4当时就因为这个卡了一会！！！

## 课下测试

### 单元测试

#### 异常处理程序（0x4180起）

```mips
	ori $6, $6, 1
	ori $2, $2, 2
```

对应的机器码为（txt文件从**第1121行**开始）：

```
34c60001
34420002
```

#### 取指异常（PC 地址未字对齐/PC 地址不在 `0x3000 ~ 0x6ffc`范围内）

PC 地址异常：

```mips
	ori $1, $1, 0x2000
	jr $1
```

PC 地址未字对齐（通过 `jr` 来实现）：

```
	ori $1, $1, 0x300d
	jr $1
label:
	ori $3, $3, 1
	beq $0, $3, label
```

#### 取数异常（只针对lw）

取数地址没有字对齐：

```
	ori $2, $2, 0x0001
	lw $1, 0($2)
```

计算地址时加法溢出/地址超出：

```
	ori $2, $2, 0xfffffff0
	lw $1, 0xfffffff0($2)
```

#### 存数异常（只针对sw）

存数地址没有字对齐：

```
	ori $2, $2, 0x0001
	sw $1, 0($2)
```

计算地址时加法溢出/地址超出：

```
	ori $2, $2, 0xfffffff0
	lw $1, 0xfffffff0($2)
```

#### 系统调用异常

```
	ori $1, $1, 2
	syscall
```

#### 未知指令

```
	ori $1, $1, 2
	mfhi $2
```

#### 算术溢出

加法溢出：

```
	ori $3, $3, 2147483647
	ori $4, $4, 1
	add $5, $3, $4
```

减法溢出：

```
	ori $3, $3, -2147483647
	ori $4, $4, 1
	sub $5, $3, $4
```

### 综合测试

```
34010000
34027ca8
3403186f
3404fffd
3405969c
3406beab
3407366d
34082fda
3409ecc8
340a9a55
340bdede
340c7639
340d7298
340eab4a
340f32c2
3410443b
34118071
3412628f
34132a25
34143337
34150002
3416fffe
34170002
34180001
34190000
341afffe
341bb43a
341cb124
341d2678
341e00b6
341ffffd
02d1a020
2149000f
0000000c
039c8020
34191ddc
af31fe28
34070761
acfa0000
3c157fff
36b5ffff
341c0002
02bce020
2149000f
00000000
340c3000
ad950000
3c01b4fa
340f0084
8df505a0
3665e638
340c0548
ad9bffd4
02068022
34083000
8d050000
341a0335
8f430000
34040895
8c920000
0000000c
00cbf820
0000000c
341f3000
afe60000
34020678
ac580000
340b3000
ad6a0000
341d3000
afab0000
02974822
01983022
340a0951
8d460000
027ba820
34133000
8e660000
341b0329
af720000
341e3000
afdf0000
340e3000
8ddf0000
34013000
8c3f0000
00000000
03aa8820
3c1084d4
00000000
341b075d
af740000
34020002
3c1d7fff
37bdffff
03a27022
34173000
aeea0000
36ee7942
34133000
ae620000
340a06f1
ad5f0000
340c0105
8d990000
3c137fff
3673ffff
34060002
0266d820
3c0dcb20
34163000
8ed70000
340104f9
ac2b0000
0000000c
341c02f1
8f830000
34160364
8ecb0000
3410023d
ae0d0000
340b3000
8d7d0000
3c115b68
2149000f
2149000f
34023000
ac580000
34011370
ac27fbd8
34013000
ac230000
0000000c
341b0218
8f6901c4
0000000c
34080250
ad060000
00000000
0370e020
34080220
ad1c066c
00000000
3413083d
ae660000
00000000
3520ffff
340b0881
8d760000
341e3000
8fd20000
34153000
8ea60000
3c1eab05
026fc022
3408017c
ad0b07f4
34110002
3c007fff
3400ffff
0011a822
34090002
3c197fff
3739ffff
03299822
0000000c
341f0274
8ff20508
36cbf7ae
3c0720cf
34153000
aea60000
00000000
3414074c
ae8f0000
009c8822
2149000f
2149000f
341f00d5
afea0000
341806bd
af070000
00d56022
340c3000
ad9f0000
0259e822
3c084cd9
2149000f
341f0458
8ffb0340
341108e9
ae3e0000
02f60022
34070002
3c0a7fff
354affff
0147f822
34073000
acf50000
341d0629
afbb0000
341d022c
afa3050c
34123000
ae540000
34c70001
0000000c
34153000
aebf0000
341c245c
8f8ffa7c
341a00f4
af4d0000
341c0938
8f950000
340e0404
adc20590
0000000c
00000000
2149000f
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
400e7000
340f0004
01cf7020
408e7000
42000018
```

## 课下两个严重bug

### 不正确的判断方式导致电路震荡

在 DM 中涉及到两个异常：取数异常和存数异常。但是他们的属性都是一致的。如何区分这两种异常呢？

原来的操作是这样的：

```
    //check exception
    always @(*) begin
        AdEL = 0;
        AdES = 0;

        //check lw
        if (!DMWr) begin
            if ((A[1:0] != 2'b00) || (A < 32'h00000000) || (A > 32'h00002fff) || overflow) begin
                AdEL = 1;
            end
        end

        //check sw
        if (DMWr) begin
            if ((A[1:0] != 2'b00) || (A < 32'h00000000) || (A > 32'h00002fff) || overflow) begin
                AdES = 1;
            end
        end
    end
```

我想通过写使能来判断是 `lw` 还是 `sw` ，从而判断是哪种异常。但是，这里会发生严重错误：

如果我在DM里边通过写使能是否为1来判断是`AdEL`还是`AdES`，`sw`肯定会出问题。在一个上升沿的时候会发生：`sw`写使能为1时，如果`AdES=1 `，那在控制器会关闭写使能，因为当前语句要作为`nop`，不让他写入。而此时AdEL又会被置1了，`always@*`里边`AdES`立刻清零。但是地址错误，所以 `AdES` 又被置1。导致电路震荡。导致**运行超时**。

因此，正确的做法是在DM中不要附加区分！全部传到控制器中，由控制器来根据当前指令区分是何种异常。

```
    //check exception
    always @(*) begin
        AdEL = 0;
        AdES = 0;

        if ((A[1:0] != 2'b00) || (A < 32'h00000000) || (A > 32'h00002fff) || overflow) begin
            AdEL = 1;
				AdES = 1;
        end
    end
```

### PC地址未对齐测试不充分，无法进入异常

原先的PC是这样的：

```
    always @(posedge clk) begin
        if (reset) begin
            PC <= 32'h00003000;
        end
        else begin
            if (NPC[1:0] != 2'b00 || (NPC < 32'h00003000) || (NPC > 32'h00006ffc)) begin
                AdEL <= 1;  //exception
            end
            else begin
                PC <= NPC;
                AdEL <= 0;
            end            
        end
    end
```

可以看到，如果NPC异常，那么就没有让 `PC <= NPC` 。这是错误的。因为如果跳转到一个未对齐的 PC 值，那么就永远无法跳到正确的PC。例如下列波形：

![69ba529c03fd511684c2460b5cdd33f](E:\myFolder_3\COLab\P5\assets\69ba529c03fd511684c2460b5cdd33f.png)

正确的做法是无论如何都让 `PC <= NPC` 。如下所示：

```
    always @(posedge clk) begin
        if (reset) begin
            PC <= 32'h00003000;
        end
        else begin
            if (NPC[1:0] != 2'b00 || (NPC < 32'h00003000) || (NPC > 32'h00006ffc)) begin
					 PC <= NPC;
                AdEL <= 1;  //exception
            end
            else begin
                PC <= NPC;
                AdEL <= 0;
            end            
        end
    end
```

这样就能产生正确的波形：

![7bc5abedc65955958aa1f93010fe238](E:\myFolder_3\COLab\P5\assets\7bc5abedc65955958aa1f93010fe238.png)

