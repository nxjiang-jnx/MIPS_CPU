#######################
# Part1 寄存器的初始化 #
#######################

# 初始化 $1 ($at)
ori $1, $zero, 1              # $1 = 1

# 初始化 $2 到 $7 ($v0 到 $a3)
ori $2, $zero, 2              # $2 = 2
lui $3, 0xFFFF                # $3 = 0xFFFF0000
ori $3, $3, 0xFFFF            # $3 = -1
lui $4, 0x7FFF                # $4 = 0x7FFF0000
ori $4, $4, 0xFFFF            # $4 = 2147483647
lui $5, 0x8000                # $5 = 0x80000000
ori $5, $5, 0x0000            # $5 = -2147483648
ori $6, $zero, 0              # $6 = 0
lui $7, 0xFFFF                # $7 = 0xFFFF0000
ori $7, $7, 0xFFFF            # $7 = -1

# 初始化 $8 到 $15 ($t0 到 $t7)
lui $8, 0xFFFF                # $8 = 0xFFFF0000
ori $8, $8, 0xFFFE            # $8 = -2
ori $9, $zero, 3              # $9 = 3
lui $10, 0xFFFF               # $10 = 0xFFFF0000
ori $10, $10, 0xFFFD          # $10 = -3
ori $11, $zero, 0xFFFF        # $11 = 65535
lui $12, 0x0001               # $12 = 0x00010000
ori $12, $12, 0x0000          # $12 = 65536
lui $13, 0xFFFF               # $13 = 0xFFFF0000
ori $13, $13, 0x0000          # $13 = -65536
lui $14, 0x1234               # $14 = 0x12340000
ori $14, $14, 0x5678          # $14 = 0x12345678
lui $15, 0x8765               # $15 = 0x87650000
ori $15, $15, 0x4321          # $15 = 0x87654321

# 初始化 $16 到 $23 ($s0 到 $s7)，使用随机值
lui $16, 0xC3AA              # $16 = 0xC3AA0000
ori $16, $16, 0x6E53         # $16 = -1000786109
lui $17, 0x7271              # $17 = 0x72710000
ori $17, $17, 0xD002         # $17 = 1919156834
lui $18, 0xFFFF              # $18 = 0xFFFF0000
ori $18, $18, 0x0001         # $18 = -65535
lui $19, 0x0000              # $19 = 0x00000000
ori $19, $19, 0x8000         # $19 = 32768
lui $20, 0x7FFF              # $20 = 0x7FFF0000
ori $20, $20, 0x0000         # $20 = 2147418112
lui $21, 0x8000              # $21 = 0x80000000
ori $21, $21, 0x0001         # $21 = -2147483647
ori $22, $zero, 0x7FFF       # $22 = 32767
ori $23, $zero, 0x8001       # $23 = 32769

# 初始化 $24 到 $25 ($t8 到 $t9)
lui $24, 0x3FFF              # $24 = 0x3FFF0000
ori $24, $24, 0xFFFF         # $24 = 1073709055
lui $25, 0x4000              # $25 = 0x40000000
ori $25, $25, 0x0000         # $25 = 1073741824

# 初始化 $26 到 $27 ($k0 到 $k1)
ori $26, $zero, 0xFFFE       # $26 = 65534
ori $27, $zero, 0xFFFF       # $27 = 65535

# 初始化 $28 到 $31 ($gp 到 $ra)
ori $28, $zero, 0x1000       # $28 = 4096
ori $29, $zero, 0x2000       # $29 = 8192
ori $30, $zero, 0x3000       # $30 = 12288
ori $31, $zero, 0x4000       # $31 = 16384

#####################
# Part2 测试0寄存器 #
#####################

# 尝试写入 $0（应保持为零）
ori $zero, $zero, 123        # $zero 仍应为 0

#####################
# Part3 测试ori指令 #
#####################

# 测试 ori 指令，使用各种边界立即数
ori $t0, $zero, 0            # $t0 = 0
ori $t1, $zero, 1            # $t1 = 1
ori $t2, $zero, 2            # $t2 = 2
ori $t3, $zero, 3            # $t3 = 3
ori $t4, $zero, 65533        # $t4 = 65533
ori $t5, $zero, 65534        # $t5 = 65534
ori $t6, $zero, 65535        # $t6 = 65535
ori $t7, $zero, 25779        # $t7 = 25779
ori $t8, $zero, 42528        # $t8 = 42528
ori $t9, $zero, 0xABCD       # $t9 = 43981

# 测试 lui 指令，使用各种立即数
lui $s0, 0                   # $s0 = 0x00000000
lui $s1, 1                   # $s1 = 0x00010000
lui $s2, 2                   # $s2 = 0x00020000
lui $s3, 3                   # $s3 = 0x00030000
lui $s4, 65533               # $s4 = 0xFFFD0000
lui $s5, 65534               # $s5 = 0xFFFE0000
lui $s6, 65535               # $s6 = 0xFFFF0000
lui $s7, 25779               # $s7 = 0x64F30000

#####################
# Part4 测试add指令 #
#####################

# 使用各种操作数组合

# 正数 + 正数
add $t0, $t1, $t2            # $t0 = 1 + 2 = 3
add $t1, $t3, $t4            # $t1 = 3 + 65533 = 65536
add $t2, $t7, $t8            # $t2 = 25779 + 42528

# 正数 + 负数
add $t3, $t1, $t5            # $t3 = 65536 + 65534
add $t4, $t4, $t6            # $t4 = 65533 + 65535
add $t5, $t9, $s6            # $t5 = 43981 + (-65536)

# 负数 + 负数
add $t6, $s4, $s5            # $t6 = (-65536) + (-65535)
add $t7, $s6, $s7            # $t7 = (-65536) + 0x64F30000
add $t8, $s5, $s6            # $t8 = (-65535) + (-65536)

# 与零相加
add $t9, $zero, $t1          # $t9 = 0 + $t1
add $s0, $t0, $zero          # $s0 = $t0 + 0

# 测试 add 与最大/最小整数
add $s1, $4, $zero           # $s1 = 2147483647 + 0
add $s2, $5, $zero           # $s2 = -2147483648 + 0
add $s3, $4, $5              # $s3 = 2147483647 + (-2147483648)

# 尝试写入 $0（应保持为零）
add $zero, $t1, $t2          # $zero 仍应为 0

#######################
# Part5 测试lw,sw指令 #
#######################

# 使用各种偏移和基址寄存器

# 准备基址寄存器，具有正数、零、负数值
ori $t0, $zero, 0            # 基址寄存器为零
lui $t1, 0x0001              # 基址寄存器为正值 (0x00010000)
ori $t1, $t1, 0x0000         # $t1 = 65536
lui $t2, 0xFFFF              # 基址寄存器为负值 (0xFFFF0000)
ori $t2, $t2, 0x0000         # $t2 = -65536

# 将数据存储到内存中的各种地址
sw $t3, 0($t0)               # 存储到地址 0
sw $t4, 4($t0)               # 存储到地址 4
sw $t5, -8($t1)              # 存储到地址 65528
sw $t6, 8($t1)               # 存储到地址 65544
sw $t7, -4($t2)              # 存储到地址 -65540
sw $t8, 0($t2)               # 存储到地址 -65536
sw $t9, 4($t2)               # 存储到地址 -65532

# 从内存加载数据到寄存器
lw $s4, 0($t0)               # 从地址 0 加载
lw $s5, 4($t0)               # 从地址 4 加载
lw $s6, -8($t1)              # 从地址 65528 加载
lw $s7, 8($t1)               # 从地址 65544 加载
lw $t3, -4($t2)              # 从地址 -65540 加载
lw $t4, 0($t2)               # 从地址 -65536 加载
lw $t5, 4($t2)               # 从地址 -65532 加载

# 尝试加载到 $0（应保持为零）
lw $zero, 0($t0)             # $zero 仍应为 0

#####################
# Part6 测试beq指令 #
#####################

# 准备用于比较的寄存器
ori $a0, $zero, 1            # $a0 = 1
ori $a1, $zero, 2            # $a1 = 2
ori $a2, $zero, 1            # $a2 = 1
lui $a3, 0xFFFF              # $a3 = -65536
ori $a3, $a3, 0xFFFF         # $a3 = -1

# beq，分支不成立（目标在之前）
beq $a0, $a1, label1         # 不相等，不应跳转
ori $t0, $zero, 0xAAAA       # 这条指令应执行
j skip1
label1:
ori $t0, $zero, 0xBBBB       # 这条指令不应执行
skip1:

# beq，分支成立（目标在之后）
beq $a0, $a2, label2         # 相等，应跳转
ori $t1, $zero, 0xCCCC       # 这条指令不应执行
label2:
ori $t1, $zero, 0xDDDD       # 这条指令应执行

# beq，跳转到自身
label3:
beq $a0, $a0, label3         # 如果跳转，将陷入死循环

# 为防止测试时死循环，我们修改 $a0
ori $a0, $zero, 0            # 现在 $a0 = 0
beq $a0, $a0, label4         # 应跳转到 label4
ori $t2, $zero, 0xEEEE       # 这条指令不应执行
label4:
ori $t2, $zero, 0xFFFF       # 这条指令应执行

# beq，目标在前方
beq $a1, $a1, label5         # 应跳转
ori $t3, $zero, 0x1111       # 这条指令不应执行
label5:
ori $t3, $zero, 0x2222       # 这条指令应执行

# 测试 beq，立即数为负（向后跳转）
beq $a2, $a2, label6         # 应跳回
ori $t4, $zero, 0x3333       # 这条指令不应执行
j skip2
label6:
ori $t4, $zero, 0x4444       # 这条指令应执行
skip2:

# 测试 beq，立即数为零（跳转到下一条指令）
beq $a1, $a2, label7         # 不相等，不应跳转
label7:
ori $t5, $zero, 0x5555       # 这条指令应执行

# 尝试使用 $0 进行比较
beq $zero, $zero, label8     # 应跳转
ori $t6, $zero, 0x6666       # 这条指令不应执行
label8:
ori $t6, $zero, 0x7777       # 这条指令应执行

# 测试多个分支，增加代码量，测试各种情况

# 循环递增寄存器
ori $t7, $zero, 0            # $t7 = 0
ori $t8, $zero, 10           # $t8 = 10
loop_increment:
add $t7, $t7, $t1            # $t7 += $t1 (之前的 $t1 = 65536)
beq $t7, $t8, end_increment  # 如果 $t7 == 10，退出循环
beq $zero, $zero, loop_increment # 无条件跳转
end_increment:

# 循环递减寄存器
ori $t9, $zero, 10           # $t9 = 10
loop_decrement:
add $t9, $t9, $a3            # $t9 += -1
beq $t9, $zero, end_decrement # 如果 $t9 == 0，退出循环
beq $zero, $zero, loop_decrement # 无条件跳转
end_decrement:

# 存储循环的结果
sw $t7, 12($t0)              # 将 $t7 存储到地址 12
sw $t9, 16($t0)              # 将 $t9 存储到地址 16

##################
# Part7 综合测试 #
##################

# 测试 sw，目标寄存器为 $0（应不存储）
sw $zero, 20($t0)            # 尝试存储 $0

# 测试 lw，目标寄存器为 $0（应保持为零）
lw $zero, 12($t0)            # 尝试加载到 $zero

# 使用各种数据模式进行测试
lui $s0, 0xAAAA              # $s0 = 0xAAAA0000
ori $s0, $s0, 0x5555         # $s0 = 0xAAAA5555
lui $s1, 0x5555              # $s1 = 0x55550000
ori $s1, $s1, 0xAAAA         # $s1 = 0x5555AAAA

# 存储和加载这些模式
sw $s0, 24($t0)              # 存储到地址 24
sw $s1, 28($t0)              # 存储到地址 28
lw $s2, 24($t0)              # 加载到 $s2
lw $s3, 28($t0)              # 加载到 $s3

# 测试这些模式的加法
add $s4, $s0, $s1            # $s4 = $s0 + $s1

# 存储结果
sw $s4, 32($t0)              # 存储到地址 32

# 测试加法溢出
lui $s5, 0x7FFF              # $s5 = 0x7FFF0000
ori $s5, $s5, 0xFFFF         # $s5 = 0x7FFFFFFF
add $s6, $s5, $s5            # $s6 = $s5 + $s5（溢出）

# 存储结果
sw $s6, 36($t0)              # 存储到地址 36

# 测试加法结果为零
add $s7, $s5, $a3            # $s7 = 0x7FFFFFFF + (-1)

# 存储结果
sw $s7, 40($t0)              # 存储到地址 40

# 使用随机立即数测试 ori
ori $t0, $zero, 12345        # $t0 = 12345
ori $t1, $zero, 54321        # $t1 = 54321
ori $t2, $zero, 0xDEAD       # $t2 = 57005
ori $t3, $zero, 0xBEEF       # $t3 = 48879

# 测试这些值的加法
add $t4, $t0, $t1            # $t4 = 12345 + 54321
add $t5, $t2, $t3            # $t5 = 57005 + 48879

# 存储结果
sw $t4, 44($t0)              # 存储到地址 44
sw $t5, 48($t0)              # 存储到地址 48

# 测试最大无符号值
ori $t6, $zero, 0xFFFF       # $t6 = 65535
lui $t7, 0xFFFF              # $t7 = 0xFFFF0000
ori $t7, $t7, 0xFFFF         # $t7 = -1

# 测试加法
add $t8, $t6, $t6            # $t8 = 65535 + 65535
add $t9, $t7, $zero          # $t9 = -1 + 0

# 存储结果
sw $t8, 52($t0)              # 存储到地址 52
sw $t9, 56($t0)              # 存储到地址 56

# 测试 sw 和 lw，使用各种偏移
sw $t0, -100($t1)            # 存储到地址 54221
sw $t1, 200($t1)             # 存储到地址 54521
lw $s0, -100($t1)            # 从地址 54221 加载
lw $s1, 200($t1)             # 从地址 54521 加载

# 测试 ori，立即数为 0xFFFF
ori $s2, $zero, 0xFFFF       # $s2 = 65535

# 测试 lui，立即数为 0x0000
lui $s3, 0x0000              # $s3 = 0x00000000

# 测试加法，结果为负数
add $s4, $s2, $s3            # $s4 = 65535 + 0

# 存储结果
sw $s4, 60($t0)              # 存储到地址 60

# 测试边界值
ori $s5, $zero, 0x7FFF       # $s5 = 32767
ori $s6, $zero, 0x8000       # $s6 = 32768

# 测试加法
add $s7, $s5, $s6            # $s7 = 32767 + 32768

# 存储结果
sw $s7, 64($t0)              # 存储到地址 64

# 测试减法（使用加法和负数）
add $t0, $s5, $a3            # $t0 = 32767 + (-1)

# 存储结果
sw $t0, 68($t0)              # 存储到地址 68

# 测试循环和条件跳转

# 初始化计数器
ori $t1, $zero, 5            # $t1 = 5
loop_test:
add $t1, $t1, $a3            # $t1 = $t1 - 1
beq $t1, $zero, loop_end     # 如果 $t1 == 0，退出循环
beq $zero, $zero, loop_test  # 无条件跳转
loop_end:

# 存储计数器结果
sw $t1, 72($t0)              # 存储到地址 72

# 测试 sw，偏移为负数，基址为正数
sw $t2, -200($t1)            # 存储到地址（$t1 - 200）

# 测试 lw，偏移为正数，基址为负数
lw $t3, 100($t2)             # 从地址（$t2 + 100）加载

# 测试在边界附近的地址
sw $t4, 0x2FFC($zero)        # 存储到地址 12284
lw $t5, 0x2FFC($zero)        # 从地址 12284 加载

# 确保不超出地址范围
# Mars DM 的地址范围为 0x0000 - 0x2FFF（0 - 12287）
# 所以最高可用地址为 12284（0x2FFC），防止越界

# 测试地址为零的情况
sw $t6, 0($zero)             # 存储到地址 0
lw $t7, 0($zero)             # 从地址 0 加载

# 测试地址为最大值的情况
sw $t8, 12284($zero)         # 存储到地址 12284
lw $t9, 12284($zero)         # 从地址 12284 加载

# 测试更多的 beq 情况

# beq，不跳转，目标在后
ori $s0, $zero, 1            # $s0 = 1
ori $s1, $zero, 2            # $s1 = 2
beq $s0, $s1, beq_label1     # 不相等，不跳转
ori $s2, $zero, 0xAAAA       # 这条指令应执行
beq_label1:

# beq，跳转，目标在前
beq $s1, $s1, beq_label2     # 相等，跳转
ori $s3, $zero, 0xBBBB       # 这条指令不应执行
beq_label2:

# beq，目标为自身（测试死循环）
# 为防止死循环，添加条件退出
ori $s4, $zero, 3            # $s4 = 3
beq_loop:
add $s4, $s4, $a3            # $s4 = $s4 - 1
beq $s4, $zero, beq_exit     # 如果 $s4 == 0，退出
beq $s1, $s1, beq_loop       # 无条件跳转
beq_exit:

# 存储结果
sw $s4, 76($t0)              # 存储到地址 76
