# P3_MIPS单周期处理器_设计文档

**指导思想**：**高内聚低耦合**，使用模块化的设计思想，做到先分析再综合。

**工程步骤**：模块搭建->总线组装->指令数据通路分析->控制器搭建->测试。

## 模块的定义

### GRF

通用寄存器组，也称为寄存器文件、寄存器堆。

<img src="E:\myFolder_3\COLab\P3\assets\image-20241022211113202.png" alt="image-20241022211113202" style="zoom:80%;" />

1. **复位**。异步复位。reset信号有效时，所有寄存器存储的数值清零，其行为与logisim自带部件寄存器的reset接口完全相同。
2. **读数据**。共有2个读出端口。A1地址读出RD1，A2地址读出RD2。
3. **写数据**。但写使能WE有效且时钟上升沿来临时，将WD数据写入A3对应的寄存器中。
4. 注意，0号寄存器恒为0，故不设计0号寄存器。对于0号寄存器，写入无效，读出恒为0（接地）。  

![image-20241023164056212](E:\myFolder_3\COLab\P3\assets\image-20241023164056212.png)

### IFU

取指令单元。

| 信号名 | 方向 |                            描述                            |
| :----: | :--: | :--------------------------------------------------------: |
|  clk   |  I   |                          时钟信号                          |
| reset  |  I   | 异步复位信号。复位值为起始地址，**起始地址：0x00003000。** |
|  NPC   |  I   |        在时钟上升沿来临时，将要更新的新PC值，32位。        |
|   OP   |  O   |         根据PC地址，从IM中读取出来的指令，为32位。         |

几个注意事项：

1. PC的**起始地址：0x00003000**，要求异步复位之后复位到起始地址，且PC使用寄存器实现。但是，寄存器的异步复位接口仅支持复位到0. 因此，设计的时候不妨用寄存器保存`PC - 0x00003000` 的值，真正的PC用探针来获得。
2. IM 用 ROM 实现，**容量为 4096 × 32bit**。需求文档说“ROM 实际地址宽度仅需 12 位”，因为2的12次方就可以满足存储4096条数据，每条数据当然是32位的，在logisim中**将ROM的位宽调整到32位即可**。
3. **下面再进行思考**：ROM的容量为 4096 × 32bit，也就是把logisim中ROM的数据位宽设计为32位，地址位宽设计到12位就没有问题。但是需求中又说了一条：地址范围：0x00003000 ~ 0x00006FFF。0x00003000 ~ 0x00006FFF中有16384个地址数。这远远超过12位。为什么会这样？原因是因为混淆了**字地址**和**字节地址**。MIPS 处理器通常以**字节**为单位进行地址访问，即“字节寻址”。因为每个字是 4 个字节，所以 4096 个**字**相当于 4096×4=16384 个**字节地址**。因此，地址范围从 0x00000000 到 0x00002FFF 表示的是**字节范围（每个字包含 4 个字节）**。但是再存储过程中，我们仍然按照“容量”的说法存储。
4. 有了上述想法，“请使用恰当的方法将 PC 中储存的地址同 IM 联系起来” 如何连接？虽然 MIPS 使用**字节寻址**（即 PC 以**字节**为单位表示地址），但由于**所有的指令都是 32 位对齐的**，也就是说，**每条指令的地址都是 4 个字节的倍数**，因此在PC地址中，最低的 2 位（表示单个**字**内的字节偏移）在 MIPS 的指令地址中**没有实际意义**。因此，正确的做法是：**把PC的值减去0x00003000，然后逻辑右移2位，再取低12位，接到ROM的地址接口。**这是这个接口最困难的点。
5. 数据通路的“上游”（输入下一个 pc 值并存在 PC 寄存器中，下一个周期 PC 寄存器将其中的 pc 值传给 ROM，ROM 取得指令并输出给 splitter）是一个Moore型状态机。对于IFU模块，我们搭建一个状态转移电路。

事实上，为了层次化更加清晰，提高可扩展性，最终选择把IFU拆成了PC、NPC、IM三个部分。

PC：

<img src="E:\myFolder_3\COLab\P3\assets\image-20241024144122419.png" alt="image-20241024144122419" style="zoom:50%;" />

NPC：

一定要注意beq指令采用**符号扩展**：

![image-20241025205652551](E:\myFolder_3\COLab\P3\assets\image-20241025205652551.png)

IM：

<img src="E:\myFolder_3\COLab\P3\assets\image-20241024144205541.png" alt="image-20241024144205541" style="zoom:50%;" />

其中，上文提到的“使用恰当的方法将 PC 中储存的地址同 IM 联系起来”被放到了IM器件中。

### DM

数据存储器。有了上面对地址范围和存储器地址的关系的关键性理解，再做DM的时候就并不是很困难了。

| 信号名 | 方向 |                描述                 |
| :----: | :--: | :---------------------------------: |
|  clk   |  I   |              时钟信号               |
| reset  |  I   |  异步复位信号。复位值为 0x00000000  |
|   A    |  I   |            32位地址输入             |
|   WD   |  I   |            32位写入数据             |
|  DMWr  |  I   | 写使能端，当为1时，从输入端存入数据 |
|   RD   |  O   |            32位数据输出             |

1. 这里再次强调一下地址的定位问题。DM的地址输入与RAM的连接和上述在IM中说的非常相似。RAM的容量为 3072 × 32bit，因此还是需要12位的地址位宽。对于32位地址输入，是以**字节**为单位的，而RAM中数据的定位是以**字**（32bit）为单位的，又因为起始地址为0，故将32位地址输入先逻辑右移2位，再截取低12位作为RAM的地址位宽。这个逻辑一定要非常熟悉。
2. RAM 应使用双端口模式，即设置 RAM 的 **Data Interface** 属性为 **Separate load and store ports**（分离的加载和存储引脚）。

![image-20241023181202370](E:\myFolder_3\COLab\P3\assets\image-20241023181202370.png)

### EXT

扩展单元。P3课下说可以使用 Logisim 内置的 Bit Extender。但是我们仍然进行封装，为后续指令添加服务。

| 信号名 | 方向 |                       描述                       |
| :----: | :--: | :----------------------------------------------: |
|  Imm   |  I   |                  16位立即数输入                  |
|   F    |  I   | 立即数扩展功能选择。0：无符号扩展。1：符号扩展。 |
|  Ext   |  O   |                   32位扩展结果                   |

![image-20241023211004667](E:\myFolder_3\COLab\P3\assets\image-20241023211004667.png)

### ALU

算术逻辑单元。P3课下的需求是：

- 提供 32 位加、减、或运算及大小比较功能。
- 加减法按无符号处理（不考虑溢出）。

|  信号名  | 方向 |                             描述                             |
| :------: | :--: | :----------------------------------------------------------: |
|  ALUOp   |  I   | **3位**功能选择信号。 **000**：add。**001**：sub。**010**：or。**011**：lui |
|   Op1    |  I   |                        32位数据输入1                         |
|   Op2    |  I   |                        32位数据输入2                         |
|  result  |  O   |                         32位结果输出                         |
|   Zero   |  O   |                   A-B==0则置为1，否则置0.                    |
| LessZero |  O   |                     A-B<0则置1，否则置0.                     |

lui只需要一个操作数，含义是，将一个立即数移至高16位，并将低16位置0.相当于左移16位的操作。

<img src="E:\myFolder_3\COLab\P3\assets\image-20241023220611245.png" alt="image-20241023220611245" style="zoom:47%;" />

## 数据通路分析

| 指令 | opcode | funct  | NPCOp | ALUOp | A3WRSel | WDSel | EXTOp | RFWE | ALUBSel | DMWr |
| :--: | :----: | :----: | :---: | :---: | :-----: | :---: | :---: | :--: | :-----: | :--: |
| add  | 000000 | 100000 |  00   |  000  |   01    |  00   |   X   |  1   |    0    |  X   |
| sub  | 000000 | 100010 |  00   |  001  |   01    |  00   |   X   |  1   |    0    |  X   |
| ori  | 001101 |   X    |  00   |  010  |   00    |  00   |   0   |  1   |    1    |  X   |
|  lw  | 100011 |   X    |  00   |  000  |   00    |  01   |   1   |  1   |    1    |  X   |
|  sw  | 101011 |   X    |  00   |  000  |    X    |   X   |   1   |  X   |    1    |  1   |
| beq  | 000100 |   X    |  01   |  001  |    X    |   X   |   X   |  X   |    0    |  X   |
| lui  | 001111 |   X    |  00   |  011  |   00    |  00   |   0   |  1   |    1    |  X   |
| nop  | 000000 | 000000 |  00   |   X   |    X    |   X   |   X   |  X   |    X    |  X   |
| jal  | 000011 |   X    |  01   |       |         |       |       |      |         |      |

![image-20241024204746176](E:\myFolder_3\COLab\P3\assets\image-20241024204746176.png)

## 总线外观

![image-20241027185323449](E:\myFolder_3\COLab\P3\assets\image-20241027185323449.png)

参考了课本上的总线设计：

![image-20241025205907560](E:\myFolder_3\COLab\P3\assets\image-20241025205907560.png)

## 思考题汇总

1. 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。

​	答：**状态存储**功能模块：GRF、DM、IM；  **状态转移**功能模块：PC、NPC、EXT、ALU、CTRL

2. 现在我们的模块中 IM 使用 ROM，DM 使用 RAM，GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

​	答：**基本合理，但仍有不足**。

IM 使用 ROM：logisim中ROM适合存储**固定不变**的数据，因为不支持数据写入。因此，较为适合存储处理器的指令集。但是，ROM的缺点是读写速度较慢，不适合现代计算机的发展。因此，IM和DM均使用RAM也未尝不可，只是要严格管理写使能信号。

DM 使用 RAM：logisim中RAM的**双端口模式**同时支持数据的读取和写入，满足lw、sw等具有读写功能指令的需求。同时，其速度快于ROM，可以方便快捷地对其存储值进行修改。但是，数据位宽为32位的RAM只能够**以字为单位**进行指令的存取，对于lb、sb等字节层面的指令，无法支持。

GRF 使用 Register：logisim中自带的寄存器搭建寄存器堆，能够满足寄存器堆的所有功能需求，且存取速度是最快的。这符合单周期架构中频繁访问寄存器的需求。

3. 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。

   答：暂时没有，但是随着指令的复杂化，ALU内部可能需要内置一个控制器。我把IFU拆成了PC、NPC、IM三个模块，**理由一**：每个模块的**功能更集中**，便于**独立设计和调试**。例如，PC负责存储当前指令的地址，NPC负责计算下一条指令的地址，IM负责从存储器中读取指令内容。模块化的设计能有效**减少逻辑的复杂性**，使电路更易于理解和维护。如果集成为一个IFU，功能耦合度太高，不易进行维护（个人观点）。**理由二**：为后续性能优化提供可能。

4. 事实上，实现 `nop` 空指令，我们并不需要将它加入控制信号真值表，为什么？

​	答：nop在CPU运行周期内不做任何行为，因此将所有控制信号置低电平即可确保CPU的各个部件不受任何影响，相当于执行了一个没有行为的周期。在这里提一句，强烈建议在控制器中**把所有信号三态设为“否”**，防止误写。

5. 阅读 Pre 的 [“MIPS 指令集及汇编语言”](http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/) 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。

​	答：强度较高，测试比较全面。主要分为两个部分：1）可以独立进行正误判断的指令测试。这部分可以排除明显的指令实现错误。2）综合判断，用于指令之间的交叉验证和相互配合。对于本次课下基本的几条基本的指令来说，是较为全面的测试。具体而言，还有的不足之处在于未测试边界或极端数据。这部分强测在下面部分由我自己提供：

## 测试概览

评测机中的样例已经对延迟槽进行了测试。自行构造的MARS测试用例主要分为7个部分：

Part1：寄存器的初始化

Part2：测试0寄存器

Part3：测试ori指令

Part4：测试add指令

Part5：测试lw/sw指令

Part6：测试beq指令

Part7：综合测试

完整的MARS代码如下：

```
#######################
# Part1 寄存器的初始化 #
#######################

# 初始化 $1 ($at)
ori $1, $zero, 1              # $1 = 1

# 初始化 $2 到 $7 ($v0 到 $a3)
ori $2, $zero, 2              # $2 = 2
lui $3, 0xFFFF                # $3 = 0xFFFF0000
ori $3, $3, 0xFFFF            # $3 = -1
lui $4, 0x7FFF                # $4 = 0x7FFF0000
ori $4, $4, 0xFFFF            # $4 = 2147483647
lui $5, 0x8000                # $5 = 0x80000000
ori $5, $5, 0x0000            # $5 = -2147483648
ori $6, $zero, 0              # $6 = 0
lui $7, 0xFFFF                # $7 = 0xFFFF0000
ori $7, $7, 0xFFFF            # $7 = -1

# 初始化 $8 到 $15 ($t0 到 $t7)
lui $8, 0xFFFF                # $8 = 0xFFFF0000
ori $8, $8, 0xFFFE            # $8 = -2
ori $9, $zero, 3              # $9 = 3
lui $10, 0xFFFF               # $10 = 0xFFFF0000
ori $10, $10, 0xFFFD          # $10 = -3
ori $11, $zero, 0xFFFF        # $11 = 65535
lui $12, 0x0001               # $12 = 0x00010000
ori $12, $12, 0x0000          # $12 = 65536
lui $13, 0xFFFF               # $13 = 0xFFFF0000
ori $13, $13, 0x0000          # $13 = -65536
lui $14, 0x1234               # $14 = 0x12340000
ori $14, $14, 0x5678          # $14 = 0x12345678
lui $15, 0x8765               # $15 = 0x87650000
ori $15, $15, 0x4321          # $15 = 0x87654321

# 初始化 $16 到 $23 ($s0 到 $s7)，使用随机值
lui $16, 0xC3AA              # $16 = 0xC3AA0000
ori $16, $16, 0x6E53         # $16 = -1000786109
lui $17, 0x7271              # $17 = 0x72710000
ori $17, $17, 0xD002         # $17 = 1919156834
lui $18, 0xFFFF              # $18 = 0xFFFF0000
ori $18, $18, 0x0001         # $18 = -65535
lui $19, 0x0000              # $19 = 0x00000000
ori $19, $19, 0x8000         # $19 = 32768
lui $20, 0x7FFF              # $20 = 0x7FFF0000
ori $20, $20, 0x0000         # $20 = 2147418112
lui $21, 0x8000              # $21 = 0x80000000
ori $21, $21, 0x0001         # $21 = -2147483647
ori $22, $zero, 0x7FFF       # $22 = 32767
ori $23, $zero, 0x8001       # $23 = 32769

# 初始化 $24 到 $25 ($t8 到 $t9)
lui $24, 0x3FFF              # $24 = 0x3FFF0000
ori $24, $24, 0xFFFF         # $24 = 1073709055
lui $25, 0x4000              # $25 = 0x40000000
ori $25, $25, 0x0000         # $25 = 1073741824

# 初始化 $26 到 $27 ($k0 到 $k1)
ori $26, $zero, 0xFFFE       # $26 = 65534
ori $27, $zero, 0xFFFF       # $27 = 65535

# 初始化 $28 到 $31 ($gp 到 $ra)
ori $28, $zero, 0x1000       # $28 = 4096
ori $29, $zero, 0x2000       # $29 = 8192
ori $30, $zero, 0x3000       # $30 = 12288
ori $31, $zero, 0x4000       # $31 = 16384

#####################
# Part2 测试0寄存器 #
#####################

# 尝试写入 $0（应保持为零）
ori $zero, $zero, 123        # $zero 仍应为 0

#####################
# Part3 测试ori指令 #
#####################

# 测试 ori 指令，使用各种边界立即数
ori $t0, $zero, 0            # $t0 = 0
ori $t1, $zero, 1            # $t1 = 1
ori $t2, $zero, 2            # $t2 = 2
ori $t3, $zero, 3            # $t3 = 3
ori $t4, $zero, 65533        # $t4 = 65533
ori $t5, $zero, 65534        # $t5 = 65534
ori $t6, $zero, 65535        # $t6 = 65535
ori $t7, $zero, 25779        # $t7 = 25779
ori $t8, $zero, 42528        # $t8 = 42528
ori $t9, $zero, 0xABCD       # $t9 = 43981

# 测试 lui 指令，使用各种立即数
lui $s0, 0                   # $s0 = 0x00000000
lui $s1, 1                   # $s1 = 0x00010000
lui $s2, 2                   # $s2 = 0x00020000
lui $s3, 3                   # $s3 = 0x00030000
lui $s4, 65533               # $s4 = 0xFFFD0000
lui $s5, 65534               # $s5 = 0xFFFE0000
lui $s6, 65535               # $s6 = 0xFFFF0000
lui $s7, 25779               # $s7 = 0x64F30000

#####################
# Part4 测试add指令 #
#####################

# 使用各种操作数组合

# 正数 + 正数
add $t0, $t1, $t2            # $t0 = 1 + 2 = 3
add $t1, $t3, $t4            # $t1 = 3 + 65533 = 65536
add $t2, $t7, $t8            # $t2 = 25779 + 42528

# 正数 + 负数
add $t3, $t1, $t5            # $t3 = 65536 + 65534
add $t4, $t4, $t6            # $t4 = 65533 + 65535
add $t5, $t9, $s6            # $t5 = 43981 + (-65536)

# 负数 + 负数
add $t6, $s4, $s5            # $t6 = (-65536) + (-65535)
add $t7, $s6, $s7            # $t7 = (-65536) + 0x64F30000
add $t8, $s5, $s6            # $t8 = (-65535) + (-65536)

# 与零相加
add $t9, $zero, $t1          # $t9 = 0 + $t1
add $s0, $t0, $zero          # $s0 = $t0 + 0

# 测试 add 与最大/最小整数
add $s1, $4, $zero           # $s1 = 2147483647 + 0
add $s2, $5, $zero           # $s2 = -2147483648 + 0
add $s3, $4, $5              # $s3 = 2147483647 + (-2147483648)

# 尝试写入 $0（应保持为零）
add $zero, $t1, $t2          # $zero 仍应为 0

#######################
# Part5 测试lw,sw指令 #
#######################

# 使用各种偏移和基址寄存器

# 准备基址寄存器，具有正数、零、负数值
ori $t0, $zero, 0            # 基址寄存器为零
lui $t1, 0x0001              # 基址寄存器为正值 (0x00010000)
ori $t1, $t1, 0x0000         # $t1 = 65536
lui $t2, 0xFFFF              # 基址寄存器为负值 (0xFFFF0000)
ori $t2, $t2, 0x0000         # $t2 = -65536

# 将数据存储到内存中的各种地址
sw $t3, 0($t0)               # 存储到地址 0
sw $t4, 4($t0)               # 存储到地址 4
sw $t5, -8($t1)              # 存储到地址 65528
sw $t6, 8($t1)               # 存储到地址 65544
sw $t7, -4($t2)              # 存储到地址 -65540
sw $t8, 0($t2)               # 存储到地址 -65536
sw $t9, 4($t2)               # 存储到地址 -65532

# 从内存加载数据到寄存器
lw $s4, 0($t0)               # 从地址 0 加载
lw $s5, 4($t0)               # 从地址 4 加载
lw $s6, -8($t1)              # 从地址 65528 加载
lw $s7, 8($t1)               # 从地址 65544 加载
lw $t3, -4($t2)              # 从地址 -65540 加载
lw $t4, 0($t2)               # 从地址 -65536 加载
lw $t5, 4($t2)               # 从地址 -65532 加载

# 尝试加载到 $0（应保持为零）
lw $zero, 0($t0)             # $zero 仍应为 0

#####################
# Part6 测试beq指令 #
#####################

# 准备用于比较的寄存器
ori $a0, $zero, 1            # $a0 = 1
ori $a1, $zero, 2            # $a1 = 2
ori $a2, $zero, 1            # $a2 = 1
lui $a3, 0xFFFF              # $a3 = -65536
ori $a3, $a3, 0xFFFF         # $a3 = -1

# beq，分支不成立（目标在之前）
beq $a0, $a1, label1         # 不相等，不应跳转
ori $t0, $zero, 0xAAAA       # 这条指令应执行
j skip1
label1:
ori $t0, $zero, 0xBBBB       # 这条指令不应执行
skip1:

# beq，分支成立（目标在之后）
beq $a0, $a2, label2         # 相等，应跳转
ori $t1, $zero, 0xCCCC       # 这条指令不应执行
label2:
ori $t1, $zero, 0xDDDD       # 这条指令应执行

# beq，跳转到自身
label3:
beq $a0, $a0, label3         # 如果跳转，将陷入死循环

# 为防止测试时死循环，我们修改 $a0
ori $a0, $zero, 0            # 现在 $a0 = 0
beq $a0, $a0, label4         # 应跳转到 label4
ori $t2, $zero, 0xEEEE       # 这条指令不应执行
label4:
ori $t2, $zero, 0xFFFF       # 这条指令应执行

# beq，目标在前方
beq $a1, $a1, label5         # 应跳转
ori $t3, $zero, 0x1111       # 这条指令不应执行
label5:
ori $t3, $zero, 0x2222       # 这条指令应执行

# 测试 beq，立即数为负（向后跳转）
beq $a2, $a2, label6         # 应跳回
ori $t4, $zero, 0x3333       # 这条指令不应执行
j skip2
label6:
ori $t4, $zero, 0x4444       # 这条指令应执行
skip2:

# 测试 beq，立即数为零（跳转到下一条指令）
beq $a1, $a2, label7         # 不相等，不应跳转
label7:
ori $t5, $zero, 0x5555       # 这条指令应执行

# 尝试使用 $0 进行比较
beq $zero, $zero, label8     # 应跳转
ori $t6, $zero, 0x6666       # 这条指令不应执行
label8:
ori $t6, $zero, 0x7777       # 这条指令应执行

# 测试多个分支，增加代码量，测试各种情况

# 循环递增寄存器
ori $t7, $zero, 0            # $t7 = 0
ori $t8, $zero, 10           # $t8 = 10
loop_increment:
add $t7, $t7, $t1            # $t7 += $t1 (之前的 $t1 = 65536)
beq $t7, $t8, end_increment  # 如果 $t7 == 10，退出循环
beq $zero, $zero, loop_increment # 无条件跳转
end_increment:

# 循环递减寄存器
ori $t9, $zero, 10           # $t9 = 10
loop_decrement:
add $t9, $t9, $a3            # $t9 += -1
beq $t9, $zero, end_decrement # 如果 $t9 == 0，退出循环
beq $zero, $zero, loop_decrement # 无条件跳转
end_decrement:

# 存储循环的结果
sw $t7, 12($t0)              # 将 $t7 存储到地址 12
sw $t9, 16($t0)              # 将 $t9 存储到地址 16

##################
# Part7 综合测试 #
##################

# 测试 sw，目标寄存器为 $0（应不存储）
sw $zero, 20($t0)            # 尝试存储 $0

# 测试 lw，目标寄存器为 $0（应保持为零）
lw $zero, 12($t0)            # 尝试加载到 $zero

# 使用各种数据模式进行测试
lui $s0, 0xAAAA              # $s0 = 0xAAAA0000
ori $s0, $s0, 0x5555         # $s0 = 0xAAAA5555
lui $s1, 0x5555              # $s1 = 0x55550000
ori $s1, $s1, 0xAAAA         # $s1 = 0x5555AAAA

# 存储和加载这些模式
sw $s0, 24($t0)              # 存储到地址 24
sw $s1, 28($t0)              # 存储到地址 28
lw $s2, 24($t0)              # 加载到 $s2
lw $s3, 28($t0)              # 加载到 $s3

# 测试这些模式的加法
add $s4, $s0, $s1            # $s4 = $s0 + $s1

# 存储结果
sw $s4, 32($t0)              # 存储到地址 32

# 测试加法溢出
lui $s5, 0x7FFF              # $s5 = 0x7FFF0000
ori $s5, $s5, 0xFFFF         # $s5 = 0x7FFFFFFF
add $s6, $s5, $s5            # $s6 = $s5 + $s5（溢出）

# 存储结果
sw $s6, 36($t0)              # 存储到地址 36

# 测试加法结果为零
add $s7, $s5, $a3            # $s7 = 0x7FFFFFFF + (-1)

# 存储结果
sw $s7, 40($t0)              # 存储到地址 40

# 使用随机立即数测试 ori
ori $t0, $zero, 12345        # $t0 = 12345
ori $t1, $zero, 54321        # $t1 = 54321
ori $t2, $zero, 0xDEAD       # $t2 = 57005
ori $t3, $zero, 0xBEEF       # $t3 = 48879

# 测试这些值的加法
add $t4, $t0, $t1            # $t4 = 12345 + 54321
add $t5, $t2, $t3            # $t5 = 57005 + 48879

# 存储结果
sw $t4, 44($t0)              # 存储到地址 44
sw $t5, 48($t0)              # 存储到地址 48

# 测试最大无符号值
ori $t6, $zero, 0xFFFF       # $t6 = 65535
lui $t7, 0xFFFF              # $t7 = 0xFFFF0000
ori $t7, $t7, 0xFFFF         # $t7 = -1

# 测试加法
add $t8, $t6, $t6            # $t8 = 65535 + 65535
add $t9, $t7, $zero          # $t9 = -1 + 0

# 存储结果
sw $t8, 52($t0)              # 存储到地址 52
sw $t9, 56($t0)              # 存储到地址 56

# 测试 sw 和 lw，使用各种偏移
sw $t0, -100($t1)            # 存储到地址 54221
sw $t1, 200($t1)             # 存储到地址 54521
lw $s0, -100($t1)            # 从地址 54221 加载
lw $s1, 200($t1)             # 从地址 54521 加载

# 测试 ori，立即数为 0xFFFF
ori $s2, $zero, 0xFFFF       # $s2 = 65535

# 测试 lui，立即数为 0x0000
lui $s3, 0x0000              # $s3 = 0x00000000

# 测试加法，结果为负数
add $s4, $s2, $s3            # $s4 = 65535 + 0

# 存储结果
sw $s4, 60($t0)              # 存储到地址 60

# 测试边界值
ori $s5, $zero, 0x7FFF       # $s5 = 32767
ori $s6, $zero, 0x8000       # $s6 = 32768

# 测试加法
add $s7, $s5, $s6            # $s7 = 32767 + 32768

# 存储结果
sw $s7, 64($t0)              # 存储到地址 64

# 测试减法（使用加法和负数）
add $t0, $s5, $a3            # $t0 = 32767 + (-1)

# 存储结果
sw $t0, 68($t0)              # 存储到地址 68

# 测试循环和条件跳转

# 初始化计数器
ori $t1, $zero, 5            # $t1 = 5
loop_test:
add $t1, $t1, $a3            # $t1 = $t1 - 1
beq $t1, $zero, loop_end     # 如果 $t1 == 0，退出循环
beq $zero, $zero, loop_test  # 无条件跳转
loop_end:

# 存储计数器结果
sw $t1, 72($t0)              # 存储到地址 72

# 测试 sw，偏移为负数，基址为正数
sw $t2, -200($t1)            # 存储到地址（$t1 - 200）

# 测试 lw，偏移为正数，基址为负数
lw $t3, 100($t2)             # 从地址（$t2 + 100）加载

# 测试在边界附近的地址
sw $t4, 0x2FFC($zero)        # 存储到地址 12284
lw $t5, 0x2FFC($zero)        # 从地址 12284 加载

# 确保不超出地址范围
# Mars DM 的地址范围为 0x0000 - 0x2FFF（0 - 12287）
# 所以最高可用地址为 12284（0x2FFC），防止越界

# 测试地址为零的情况
sw $t6, 0($zero)             # 存储到地址 0
lw $t7, 0($zero)             # 从地址 0 加载

# 测试地址为最大值的情况
sw $t8, 12284($zero)         # 存储到地址 12284
lw $t9, 12284($zero)         # 从地址 12284 加载

# 测试更多的 beq 情况

# beq，不跳转，目标在后
ori $s0, $zero, 1            # $s0 = 1
ori $s1, $zero, 2            # $s1 = 2
beq $s0, $s1, beq_label1     # 不相等，不跳转
ori $s2, $zero, 0xAAAA       # 这条指令应执行
beq_label1:

# beq，跳转，目标在前
beq $s1, $s1, beq_label2     # 相等，跳转
ori $s3, $zero, 0xBBBB       # 这条指令不应执行
beq_label2:

# beq，目标为自身（测试死循环）
# 为防止死循环，添加条件退出
ori $s4, $zero, 3            # $s4 = 3
beq_loop:
add $s4, $s4, $a3            # $s4 = $s4 - 1
beq $s4, $zero, beq_exit     # 如果 $s4 == 0，退出
beq $s1, $s1, beq_loop       # 无条件跳转
beq_exit:

# 存储结果
sw $s4, 76($t0)              # 存储到地址 76
```

