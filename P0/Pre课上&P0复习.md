# Pre课上&P0复习

Pre整体不难，有三个题目，分别是：

1. Logisim时序电路（数列）
2. Verilog16位矩阵乘法
3. MIPS判断最长的递增序列。

下面简单复习一下P0，也就是Logisim的第一次上机：

## CRC校验

### 什么是CRC校验

首先我们了解一下什么是CRC校验。CRC 校验是数据通信领域中最常用的一种查错校验方式，它对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。（“帧” 在本章指的是数据的二进制码）

需要先了解一种特殊的除法：**“模二除法”**。它与算术除法类似，但在做减法时既不向上借位，也不比较除数和被除数相同位数值的大小；它的运算法则为 `1-1=0`，`0-1=1`，`1-0=1`，`0-0=0`，例如 `1100-1001=0101`。

<img src="E:\myFolder_3\24秋\CO笔记\assets\image-20240929185917968.png" alt="image-20240929185917968" style="zoom:50%;" />

发现，模二除法中的**减法**和**异或**的效果是相同的，所以模二除法可以用异或来完成。

知道了模二除法的计算过程，CRC 校验码的计算就很简单了。我们只需要**将原帧补上（除数位数 - 1）个 0 作为被除数**，然后进行模二除法即可。举个例子，我们要发送的帧 A 为 10011，发送端和接收端共同选定的除数 B 为 1110。因为 B 是 4 位二进制数，我们需要在 A 的后面补上 3 个 0，从而得到 A’=10011000。我们将 A’ 作被除数，B 作除数，进行“模二除法”。

<img src="E:\myFolder_3\24秋\CO笔记\assets\image-20240929190629547.png" alt="image-20240929190629547" style="zoom:50%;" />

最后得到的余数是一个三位数（注意如果不是三位，也要在前面补零来凑齐三位），这就是要求的校验码。我们**将得到的校验码 110 拼接在原数据帧的后面**，就得到了要发送的新帧 A’’=10011110。这样就完成了 CRC 校验码的生成。

### 构造子函数

这个题目首先给了我们封装函数的思想。可以把这个计算过程分解为多次进行被除数为 4 位的除法计算。因此我们引入“4 位模二除法器”这个间接层，这样问题就变成了两个部分:

- 设计四位模二除法器
- 使用四位模二除法器搭建 8 位 CRC 校验码计算电路

## 实现GRF

这里，要积累一下DMX“三态”的使用方法，因为这导致了一念之间就没有输出（评测机的logging原理导致了如果输出一直不变，就忽略输出，导致没有输出）。

DMX的三态，指0，1，高阻态。

如果不开三态，那么DMX分配的数据都只有两个状态，非0即1.那么就是说，选择端的数据决定了DMX左边的输入数据要分配到哪一个输出端。但是，对于除了这个输出端的其他端口呢？全是0.什么叫全是0？就是0被分配到其他端口连接的位置，也就是说，其他端口连着的位置的原有数据都会**被0覆盖**。这是很致命的一个现象。也导致了评测错误。那么，如何避免 呢？

三态。三态保证了没有被选中的输出端输出为 高阻态（floating），也就是说，不会对正在进行中的电路产生覆盖的影响。这是我们需要的。

**使用DMX，记得检查一下三态**。

## Logisim导航

首先再次复习一下两种基本的状态机：

![image-20240929192448519](E:\myFolder_3\24秋\CO笔记\assets\image-20240929192448519.png)

注意，Moore型状态机的意思是输出**不直接**与输入有关。

这个题理论上应该要用mealy，因为我们只能通过当前状态（也就是当前位置）和当前输入（也就是马上要往哪里走）来确定下一状态有没有撞墙（或有没有到达）。光凭当前位置，不知道hit等于1还是等于0.但是，强行要把Mealy改成Moore也是可以的——在输出逻辑的时候加一个寄存器挡一下即可，保证输出不直接和当前输入有关。

**Mealy比Moore快一个周期**。其实这里”周期“的概念说法也不严谨，就是Mealy本质上是“异步的”，只要输入变，输出一定变。但是Moore是“同步的”，输入什么时候变，我才不管呢，只有在时钟上升沿到来时才有效。

## Logisim中的FSM

字符自动机必考，xdm。这个题我有一个疑问。b{1,2}[ac]{2}这个正则表达式只要求“字串”匹配，那就是bbbbbbbbac都可以，无论前导有多少个b，那b{1,2}似乎是不是没有什么意义（

那这道题状态数量就很少了。

借着这道题，**一定要理解正则表达式。**

正则表达式是对字符串操作的一种逻辑公式，它通常被用来检索、替换符合某个模式的文本。它的规则比较复杂，我们现在只讲解其中比较简单的几种规则。

- [...]是指要匹配中括号中的字符(注意是字符不是字符串),比如[xyz]就是要匹配x y z这三个字符中的**任意一个**。
- {...}是指要求匹配”{“前的那个字符几次，比如a{2}是指要匹配a两次，a{2,4}是指要匹配a 2至4次,a{,4}指要匹配a 0至4次，a{2,}指要匹配a 2至无穷次。**所以[cd]{1,2}就是要求匹配(c或d)一次或两次,即cc、dd、cd、dc、c、d都是能匹配的。**这句话一定要理解！什么叫匹配（c或d）多少多少次。（c或d）是作为一个整体。
- (...)是指将()内的字符串视为一个整体，比如(ab){1,2}对应的就是ab或abab。
- 我们也可以将多条表达式组合起来，如a{2}b{2}就是指匹配a两次后再匹配b两次,即匹配aabb。

因此，在这道题中，b可以1或2次，对于后面，只能是aa、ac、ca、cc。一定要理解“匹配（a或c）2次”。（a或c）是一个整体！第一次，匹配了（a或c），第二次，匹配了（a或c）。这样理解。

## logisim中时序逻辑的同步复位和异步复位

- 异步复位：直接复位信号连接寄存器的Clear。因为异步复位涉及到更改寄存器的内部结构。
- 同步复位：使用MUX。复位信号连接MUX的选择端。
