# P0课上&P1课下

P0课上全部通过了，然是关于logisim，还有一个地方卡了很久：

**关于counter达到最大之后的状态**。应该选择停留在最大值，而不是其他选项，以防止一些状态机状态的混乱。

Verilog由于有testbench，因此非常利于debug，debug的方式也非常直观，就是看那个波形。一般来说，根据题目的示例波形精心构造，如果情况一直，就基本可以通过。需要熟练使用testbench，熟悉组合逻辑和时序逻辑的testbench打法。

下面以几个题目为例，回顾一下Verilog上机的注意事项：

## Splitter

最基本的情景：

使用 Verilog 搭建一个32位 Splitter , 给定一个32位的二进制数作为输入，将其划分为四个8位的二进制数作为输出。

```verilog
module splitter(
    input [31:0] A,
    output [7:0] O1,
    output [7:0] O2,
    output [7:0] O3,
    output [7:0] O4
    );

    assign O1 = A[31 : 24];
    assign O2 = A[23 : 16];
    assign O3 = A[15 : 8];
    assign O4 = A[7 : 0];

endmodule
```

这就是一个简单的分线器。我们借此来回顾 verilog 中**赋值的几个注意事项**：

### 注意位宽的定义与声明方法

比如说，在上述代码中，`A` 是32位的，而定义的时候要写 `input [31:0] A` 不要犯最基础的错误，我曾经就在一个复杂的题目中出现位宽的混乱。尤其是在赋值的过程中。

### 数字字面量

Verilog 中的数字字面量可以按**二进制（b 或 B）**、八进制（o 或 O）、**十六进制（h 或 H）**、**十进制（d 或 D）**表示。

下面有一个经典的练习题：

![image-20241009161952640](E:\myFolder_3\24秋\CO笔记\assets\image-20241009161952640.png)

解析：

2b10 选项缺少了位宽与数之间的 '。

3'101 项，进制缺省时默认为 10 进制，但 B 项位宽为 3 ，十进制数上限为 7 ，超过位宽上限表示是不合法的。

'h20 项正确，位宽缺省时默认为 32 位。

32'd-100 项中，在数字本身之中表示负号是不合法的。

8'o100 项 表示 8 位八进制 100，该数本身占 7 位，没有超过位宽上限，正确。

8'b_0011_1010 项，数字中间可以用短横 _ 隔开， Verilog 语法规定短横只能出现在数字之间。

4'b10x0 和 4'b101z 均符合规范，特殊值 x 和 z 可以出现在多位数字中的某几位。

-8'd5 项正确，Verilog 数字本身并不能添加负号，这一表述可以看作对数字的运算，它是合法的。



这里，经常会在字符自动机中出现判断 `in` 是不是某个字母的情况。**Verilog中不支持直接的字符表示，必须要完全使用二进制ASCII码**。

经过与大佬讨论后，得知在书写代码时省略位宽和进制，直接写十进制数就可以。前提是必须要在模块中明确定义好位宽。因为Verilog中规定，省略位宽时采用默认位宽（与机器有关，一般为 **32 位**），省略进制时默认为**十进制**。

但是，为了标程规范，我们统一仍然是**全部写上**：**位宽+进制+数字**，**不要简写**。

例如：`8’d32` 表示空格字符。

以防万一，记住常用的ASCII码：

### 常用的ASCII码

- 32：空格
- 48：’0‘
- 65：’A‘
- 97：’a‘

### 常用运算符

Verilog HDL 中有相当多的运算符都与 C 语言基本相同，如：

- 基本运算符：`+`, `-`, `*`, `/`, `%` 等
- 位运算符：`&`, `|`, `~`, `^`, `>>`, `<<` 等
- 逻辑运算符：`&&`, `||`, `!` 等
- 关系运算符：`>`, `<`, `>=`, `<=` 等
- 条件运算符：`? :`

这些运算的运算规则与 C 语言相同，只是在操作数中出现了不定值 `x` 和高阻值 `z` 的话最终结果可能也是带 `x` 或 `z` 的。**另外 Verilog 中没有自增、自减运算符**。下面主要介绍其他与 C 不同的部分。

- **逻辑右移**运算符 `>>` 与**算术右移**运算符 `>>>`

  它们的区别主要在于前者在最高位**补 0**，而后者在最高位**补符号位**。

- 相等比较运算符 `==` 与 `===` 和 `!=` 与 `!==`

  `==` 和 `!=` 可能由于不定值 `x` 和高阻值 `z` 的出现导致结果为**不定值 `x`**，而 `===` 和 `!==` 的结果一定是**确定的 0 或 1**（`x` 与 `z` 也参与比较，就是看是不是长得完全一样）。

- 阻塞赋值 `=` 和非阻塞赋值 `<=`

  **在描述时序逻辑时要使用非阻塞式赋值 `<=`** 。

- 位拼接运算符 `{}`

  这个运算符可以将几个信号的某些位**拼接**起来，例如 `{a, b[3:0], w, 3'b101};`；可以简化重复的表达式，如 `{4{w}}` 等价于 `{w,w,w,w}`；还可以嵌套，`{b, {3{a, b}}}` 等价于 `{b, {a, b, a, b, a, b}}`，也就等价于 `{b, a, b, a, b, a, b}`。一定要注意，你可能也发现了，`{b, {3{a, b}}}`这个例子下，**后一项要加括号，因为不能直接光秃秃出现数字。**

- 缩减运算符

  运算符 `&`（与）、`|`（或）、`^`（异或）等作为单目运算符是**对操作数的每一位汇总运算**，如对于 `reg[31:0] B;` 中的 `B` 来说，**`&B` 代表将 `B` 的每一位与起来得到的结果，最后得到的是1位的。**

这里我再扩充一下，关于这个 `^`（异或）的缩减运算符。

首先转化为二进制：32'ha081 = 32'b0000_0000_0000_0000_1010_0000_1000_0001

然后，就老老实实从左到右按位异或起来就可以：0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^
0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 0 ^1 ^ 0 ^ 0 ^ 0 ^ 0 ^ 1 ^ 0 ^ 1 = 1.

### 分线器的细节

指定端口位宽时，如果形式为`in[a : b]`，则两侧的数字均不能含有变量。

看一个例子：

实现一个 256to1 的多路选择器，输入端口位宽为 1024，输出端口位宽为 4。根据一个 8 位的选择端口 sel , 将输入中的对应 4 位输出。例如，当 sel 为 8'b00000011 时，将 in[15 ：12] 输出。

程序：

```Verilog
module top_module(
	input [1023:0] in,
    input [7:0] sel,
    output [3:0] out 
);
    assign out = in[sel * 4 + 3 : sel * 4]; 
endmodule
```

以上的程序错误之处在于：**两侧的数字均不能含有变量**。正确的写法是：

```verilog
assign out = in[sel * 4 +: 4];
```

`+:` 是一种**位选择操作符**，用于**指定一个范围的位**。这种表示法的关键在于它能够**根据给定的起始位和位宽，自动确定需要选择的位范围。**

- `sel * 4`：表示选择的**起始位**。
- `+: 4`：表示从起始位开始，选择接下来的 4 位。

这种方式是正确的。还有什么别的方式？如果情况比较少，直接 `case` 算了。

## ALU

![image-20241009190942078](E:\myFolder_3\24秋\CO笔记\assets\image-20241009190942078.png)

```verilog
module alu(
    input [31:0] A,
    input [31:0] B,
    input [2:0] ALUOp,
    output reg [31:0] C
    );

    always @(*) begin
        case(ALUOp)
            3'b000: C = A + B;           // 加法
            3'b001: C = A - B;           // 减法
            3'b010: C = A & B;           // 按位与 
            3'b011: C = A | B;           // 按位或
            3'b100: C = A >> B;          // 无符号右移
            3'b101: C = $signed(A) >>> B; // 有符号算术右移
            default: C = 32'b0;          // 默认
        endcase
    end

endmodule
```

以上的写法肯定没有问题，但是我第一次并不是这样写的。我第一次全程使用三目运算符，但是发生了错误。一整个长长的三目运算符不管有多少个条件，始终都是一个表达式。一个表达式中只要有无符号数，那么就认为整体 都是无符号运算。因此，在三目运算符的写法中，`$signed(A) >>> B` 失效。

因此，我们有必要来回顾下Verilog中非常重要的一个概念——有符号数和无符号数，并且知道如果三目运算符中必须要有有符号操作，究竟应该怎么写。

### 有符号数的处理总结

`wire`、`reg` 等数据类型**默认都是无符号的**。当你希望做符号数的操作时，你需要使用 **`$signed()`**。在对无符号数和符号数同时操作时，Verilog 会自动地做数据类型匹配，**将符号数向无符号数转化**。比如说在执行 `a > $signed(b)` 时，`a` 是无符号数，`$signed(b)` 是符号数，Verilog 默认向无符号类型转化，得到的结果仍是无符号数的比较结果。

也就是说，对于一个复杂表达式，只要有一个部分是无符号的，整体就会转化为无符号的。

对于有符号和无符号杂糅的复杂表达式（尤其是三目运算）怎么办？

**对于复杂的表达式避免使用 `$signed()` ，如果希望使用 `$signed()` 可以将这一部分抽离出来单独作为一个变量，比如**

```verilog
wire [1:0] in_a,in_b,out;
wire [1:0] op;
// wrong !!!
assign out = op == 0? in_a + in_b:
             op == 1? in_a - in_b:
             op == 2? in_a >>> in_b:
    		 $signed(in_a) >>> in_b;	//无法实现功能，因为整个表达式无符号
// correct
wire [1:0] shift;
assign shift = $signed(in_a) >>> in_b;
assign out = op == 0? in_a + in_b:
             op == 1? in_a - in_b:
             op == 2? in_a >>> in_b:
             shift;
```

这里需要注意，算术右移在左操作数无符号时高位仍然补0，与逻辑右移效果相同。

有符号和无符号在**符号扩展**的情境下非常重要，如下例：

```verilog
wire [1:0] unsignedValue = 2'b11;
wire [31:0] extendedValue;
// use $signed()
assign extendedValue = $signed(unsignedValue);	//自动符号扩展
// do not use $signed()
assign extendedValue = {{30{unsignedValue[1]}},unsignedValue};
```

上面的例子说明了，如果你实在担心使用 `$signed()` 会出现意想不到的 bug，那么最简单的方式就是避开它，虽然两种方式都正确。



上面说完了，下面我们回到ALU的三目运算实现：

```verilog
module alu(
    input [31:0] A,
    input [31:0] B,
    input [2:0] ALUOp,
    output [31:0] C
    );

    wire [31 : 0] shift;
    assign shift = $signed(A) >>> B;

    assign C = (ALUOp == 3'b000) ? A + B : 
               (ALUOp == 3'b001) ? A - B : 
               (ALUOp == 3'b010) ? A & B : 
               (ALUOp == 3'b011) ? A | B : 
               (ALUOp == 3'b100) ? A >> B : 
               (ALUOp == 3'b101) ? shift : 
                                   32'b0;

endmodule
```

也就是**把有符号的部分拿出去**。

可以打一下testbench看一下上述代码 的具体测试：

![image-20241009195312518](E:\myFolder_3\24秋\CO笔记\assets\image-20241009195312518.png)

看到，实现了正确的算术右移2位。testbench核心部分如下：

```verilog
	initial begin
		// Initialize Inputs
		A = -32'd8;
		B = 32'd2;
		ALUOp = 3'b101;

		// Wait 100 ns for global reset to finish
		#100;
        
		// Add stimulus here

	end
```

## EXT

EXT为扩展单元，其主要功能是完成将输入到其中的16位数据进行**符号扩展、零扩展以及将输入的16位数加载到高位**等操作。

![image-20241009200701198](E:\myFolder_3\24秋\CO笔记\assets\image-20241009200701198.png)

```verilog
module ext(
    input [15:0] imm,
    input [1:0] EOp,
    output [31:0] ext
    );

    assign ext = (EOp == 2'b00) ? {{16{imm[15]}}, imm} : 
                 (EOp == 2'b01) ? {16'b0, imm} :
                 (EOp == 2'b10) ? {imm, 16'b0} :
                 (EOp == 2'b11) ? {{16{imm[15]}}, imm} << 2'b10 :
               					  32'b0;

endmodule
```

当然，有了刚才“有符号数的处理”那部分关于符号扩展的基础，还可以这么写：

```verilog
module ext(
    input [15:0] imm,
    input [1:0] EOp,
    output [31:0] ext
    );

    wire [31 : 0] extend;
    assign extend = $signed (imm);	//自动进行位扩展

    assign ext = (EOp == 2'b00) ? extend: 
                 (EOp == 2'b01) ? {16'b0, imm} :
                 (EOp == 2'b10) ? {imm, 16'b0} :
                 (EOp == 2'b11) ? {{16{imm[15]}}, imm} << 2'b10 :
               					  32'b0;

endmodule
```

本质上都是一样的。这一题一定要掌握**位拼接运算符**的使用。我们之前已经介绍过。特别被要注意**大括号**。

## Gray

接下来进入时序逻辑。有限状态机是课下和课上，在学习Verilog基础部分时候的重点，基本方法就是确定状态，给出状态转移，使用 `case` 进行搭建状态转移，最后利用纯组合逻辑构造输出函数。

现在的任务就是设计一个加强版的计数器——格雷码计数器。 

![image-20241009202301025](E:\myFolder_3\24秋\CO笔记\assets\image-20241009202301025.png)

任务需求：

1、 在任意一个时钟**上升沿**到来的时候，如果复位信号有效，则将计数器清零；（看出是同步复位）

2、 每个时钟上升沿到来的时候，如果**使能信号有效**，计数器的值+1；

3、 **在满足1时，即使2的条件满足，也不必执行2；**（什么意思？？如何设计？？）

4、 计数器初值为0；

5、 当计数器的值在+1后出现溢出的情况时，将会回到零，同时从发生溢出的这个时钟**上升沿开始**，溢出标志位将会持续输出1，直到计数器被清零为止（其余情况下溢出标志位必须为0）。

<img src="E:\myFolder_3\24秋\CO笔记\assets\image-20241009202440149.png" alt="image-20241009202440149" style="zoom:50%;" />

总结分析：

这个题目是非常规范的有限状态机题目，也非常符合上面说的做题方法。

但是，折射出一个非常重要，也非常常见的功能，也就是**复位**和**使能**。我们这里总结一下，Verilog有几大常见的复位和使能可以做成模板：

- 同步复位
- 异步复位
- 同步/异步复位+使能选项

下面展开论述。

### 同步复位、异步复位与使能的设计

时序逻辑中这几个功能需求，本质上都是对 `always` 语句的延展。

#### 同步复位

```verilog
always @(posedge Clk) begin
    if (Reset) begin
       //reset 
    end
    else begin
       //function code here 
    end
end
```

#### 异步复位

```verilog
always @(posedge Clk or posedge Reset) begin
    if (Reset) begin
       //reset 
    end
    else begin
       //function code here 
    end
end
```

这里注意 `or` 的用法。`or` 比较特殊，简单理解就是“always中敏感条件的或”，一定注意：**只能在always敏感列表中使用**！别的地方错误。 别的地方也可能会有“或”的意思需要使用，比如说 `if` 语句中的条件可能会遇到“逻辑或”，比如输入等于这个数或者那个数的时候，怎么怎么样。**这个时候用 `||`**，跟C语言里边一样，这是表示布尔运算，体现的是逻辑。 

#### 同步/异步复位与使能端组合

有的需求要添加使能端 `En` 。要求使能端有效时，才执行某些指令。这时候怎么办呢？

```verilog
always @(posedge Clk) begin	//如果是同步复位
    //always @(posedge Clk or posedge Reset) begin，如果是异步复位
    if (Reset) begin
       //reset 
    end
    else if (En) begin
        //function code here 
    end
    else begin
        //everything don't move
    end
end
```

一定要注意**使能的选择语句摆放的位置**。上述模板经过多次试错和测验，总之就是：使用**三个分支**。`En` 和 `Reset` 同级，属于**并行关系，而不是其他关系**，否则就可能发生位置的错误。



按照以上的指导思想就可以进行格雷编码计数器的编写：

```verilog
module gray(
    input Clk,
    input Reset,
    input En,
    output reg [2:0] Output,
    output reg Overflow
    );

    initial begin
        Output <= 3'b0;
        Overflow <= 1'b0;
    end

    always @(posedge Clk) begin
        if (Reset) begin
            Output <= 3'b0;
            Overflow <= 1'b0;
        end
        else if (En) begin
             // 更新计数器
            case (Output)
                //number: 
                //begin 
                //   Output <= ......;
                //   Overflow <= ......;
                //end
                //......
                default: 
                begin
                    Output <= 3'b000;
                    Overflow <= Overflow;
                end 
            endcase
        end
        else begin
            // 当 En 为低电平时，保持当前状态
            Output <= Output;
            Overflow <= Overflow;
        end
    end
endmodule
```

## 表达式状态机

现在有这样一类表达式F的字符串需要你来验证它们的合法性：

1、表达式F中只含有数字0-9，加号+，乘号*。

2、表达式F可以按如下的规则产生：

a. 单个数字[0-9]是F； b. 如果**X**是F，**Y**是F，**X+Y**也是F； c. 如果**X**是F，**Y**是F，**X\*Y**也是F。

排除显而易见的所用符号不合法，所有的非法情况总结如下：

![image-20241009210718854](E:\myFolder_3\24秋\CO笔记\assets\image-20241009210718854.png)

首先明确，什么是“显而易见的所用符号不合法”？就是有乱七八糟扯淡符号，也就是在1的条件之外，即不能出现除了加号和乘号的其他符号。

![image-20241009210859034](E:\myFolder_3\24秋\CO笔记\assets\image-20241009210859034.png)

输入：s = **1+2+3+4** 输出：out = 1

输入：s = **1+2+3+** 输出：out = 0



综合分析：

这是一道非常规范的**字符状态机**。只需要按照上面介绍的基本方法去做即可，找清楚状态，构造状态转移和状态输出函数。这类状态机不太需要可以追求是Moore还是Mealy类型，按照题目的具体要求具体开发即可。下面针对字符状态机介绍一下Verilog中**函数**的定义方法：

### 函数

例如，字符状态机中经常涉及到三类字符：数字字符、英文字母和其他字符。那么下面以判断是不是英文字母为例，介绍一下函数的定义：

```verilog
// 检查输入字符是否为字母 
function is_letter(input [7:0] c);
    begin
        is_letter = ( (c >= 8'd65 && c <= 8'd90) || (c >= 8'd97 && c <= 8'd122) );
    end
endfunction
```

我们观察一下这个函数定义方法。别的最基础的不说，最重要的观察到传参用了一个 `input` 。这是什么意思？似乎对参数类型没有明确限制（`reg` 、`wire` ……）？事实真的如此吗？

`input`指定的是函数参数的传递方向，表明该参数是从外部输入到函数中的。**在函数内部，所有的输入信号默认是 `wire` 类型的**，这意味着**函数输入参数只能是 `wire` 类型**，而不能是 `reg` 类型。你不能在函数定义中直接使用 `reg` 类型作为输入参数。

函数参数在 Verilog 中的类型有如下规则：

- 如果你在函数中定义输入参数，**它自动被视为 `wire` 类型**，并且只能使用连接到 `wire` 类型信号的值调用。
- 你不能对输入参数（例如 `input [7:0] c`）执行赋值操作，因为它是 `wire` 类型，不能存储值。

对于上述例子，在后续代码中这样使用这个函数：

```verilog
`S0: status <= (in == 8'd32) ? `S1 :    //空格
                (is_letter(in)) ? `S0:  //仍然是字母
                `S10;                   //是标点符号
```

## BlockChecker

**输入由ASCII字母和空格组成**。一个或多个连续出现的字母构成一个单词，单词**不区分大小写**，单词之间由一个或多个空格分隔开。检查工具检查**自复位之后的输入中**，begin和end是否能够匹配。

匹配规则类似括号匹配：一个begin只能匹配一个end，**但是一个匹配的begin必须出现在对应的end之前**；允许出现嵌套；最后若出现不能按上述规则匹配的begin或end，则匹配失败。

输入的读取在**时钟上升沿**进行。

匹配示例：Hello world  begin comPuTer orGANization End。

不匹配示例：eND beGin study。

| 信号名  | 方向 | 描述                                             |
| :------ | :--- | :----------------------------------------------- |
| clk     | I    | 时钟信号                                         |
| reset   | I    | 异步复位信号（高电平有效，复位时将输入记录清空） |
| in[7:0] | I    | 当前输入字符的ASCII码                            |
| result  | O    | 当前输入是否能够完成begin和end的匹配             |

![image-20241010000206246](E:\myFolder_3\24秋\CO笔记\assets\image-20241010000206246.png)



综合分析：

这道题目核心和难点在于**状态的封锁**。对于把`cnt_begin == cnt_end` 作为本题核心逻辑标程设计的做法，核心就是如何处理一个匹配的begin必须出现在对应的end之前的问题。也就是说，如果第一个完整的end出现在第一个begin之前，那么再见，复位之前永远没戏。所以，要设计一个**封锁机制**。

当然还要留一个后手，如果是endx begin（就是第一个end后仍单词没完，还有字母）的情况，对不起，我误判了，在end结束了之后我把你打死，但是又来了个连续的x，我只能冤枉了，把你扶回正路。因此，这种封锁机制还要有一个**回退机制**。

在这样设计完了之后，测评机有几个测试点死活过不了。为什么？这里有一个比较隐晦的点：也就是说你这个”封锁机制“到底严格到什么程度。正确的做法是定义一个 `unmatched` 寄存器来记录是不是出现”第一个end出现在begin之前“这种情况，**且**给”封锁机制“构建一个独有的新状态。错误的做法是**仅**定义一个 `unmatched` 寄存器。

这里需要细品。问题就出现在这里，如果使用错误的做法，那么对于这种情况：end begin endx，就会出错，也就是没有锁死，错误的波形如下图所示：

![ea83826e6635fc40f2a3b4fecd3f22e.png](E:\myFolder_3\24秋\CO笔记\assets\ea83826e6635fc40f2a3b4fecd3f22e.png)
