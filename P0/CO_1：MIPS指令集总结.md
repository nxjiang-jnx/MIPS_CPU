# CO_1：MIPS指令集总结

### 什么是 MIPS 汇编？

MIPS 是一种 **RISC**（精简指令集计算机）架构，它的特点是使用简单、少量的指令来完成复杂的计算任务。汇编语言直接控制计算机硬件，因此 MIPS 指令非常贴近硬件操作。

### MIPS 基本概念：

1. **寄存器**：CPU 中的一个“存储单元”，用来存储数据。MIPS 中有 32 个寄存器，常用的有：
   - `$0`：值永远是 0，不能修改。
   - `$t0 - $t9`：临时寄存器，存储中间结果。
   - `$s0 - $s7`：保存寄存器，存储需要长期保留的值。
   - `$a0 - $a3`：函数参数寄存器，用于传递参数。
   - `$v0, $v1`：返回值寄存器，用于函数返回值。
   - `$ra`：返回地址寄存器，用于函数调用返回。
2. **指令格式**：
   - **R 型指令**：用于寄存器之间的操作（如加法、减法）。
   - **I 型指令**：包含一个立即数（数字常量），用于简单的数值计算或内存访问。
   - **J 型指令**：用于跳转（`jump`）指令。

### 最常用的指令：

#### 1. **数据操作指令**

这些指令用于基本的加法、减法和数据传输。

- **`add`**：将两个寄存器中的值相加，结果存入另一个寄存器。
  - 例子：`add $t0, $t1, $t2` 表示 `$t0 = $t1 + $t2`。
- **`sub`**：将两个寄存器中的值相减。
  - 例子：`sub $t0, $t1, $t2` 表示 `$t0 = $t1 - $t2`。
- **`ori`**：将寄存器与一个立即数进行按位或操作。
  - 例子：`ori $t0, $0, 1` 表示将 1 赋值给 `$t0`（因为 `$0` 永远为 0）。
- **`addi`**：将寄存器与一个立即数相加。
  - 例子：`addi $t0, $t1, 5` 表示 `$t0 = $t1 + 5`。

#### 2. **内存操作指令**

这些指令用于从内存加载数据或将数据存储到内存。

- **`lw` (load word)**：从**内存**加载 32 位数据到**寄存器**。后面详细介绍。
  - 例子：`lw $t0, 0($t1)` 表示将 `$t1` 所指的**地址**的值加载到 `$t0` 中。
- **`sw` (store word)**：将**寄存器**中的 32 位数据存储到**内存**。
  - 例子：`sw $t0, 0($t1)` 表示将 `$t0` 中的值存储到 `$t1` 所指的内存地址。

#### 3. **跳转和分支指令**

这些指令用于控制程序的执行流程。

- **`j` (jump)**：无条件跳转到指定地址。
  - 例子：`j label` 表示跳转到 `label` 标签处。
- **`jal` (jump and link)**：跳转到指定地址并保存返回地址到 `$ra`。
  - 例子：`jal function` 表示跳转到 `function` 并**保存返回地址**。
- **`jr` (jump register)**：跳转到**寄存器中存储的地址**。
  - 例子：`jr $ra` 表示返回调用函数处继续执行。
- **`beq` (branch if equal)**：如果两个寄存器中的值相等，则**跳转**。
  - 例子：`beq $t0, $t1, label` 表示如果 `$t0 == $t1`，则跳转到 `label`。
- **`bne` (branch if not equal)**：如果两个寄存器中的值不相等，则**跳转**。
  - 例子：`bne $t0, $t1, label` 表示如果 `$t0 != $t1`，则跳转到 `label`。

#### 4. **移位操作指令**

这些指令用于对寄存器中的值进行左移或右移操作。

- **`sll` (shift left logical)**：将寄存器中的值**按位左移，低位补 0**。
  - 例子：`sll $t0, $t1, 2` 表示将 `$t1` 的值左移 2 位，结果存入 `$t0`。
- **`srl` (shift right logical)**：将寄存器中的值**按位右移，高位补 0**。
  - 例子：`srl $t0, $t1, 2` 表示将 `$t1` 的值右移 2 位，结果存入 `$t0`。

------

### 如何记住这些指令？

1. **从常用的指令开始**：如 `add`, `sub`, `lw`, `sw`, `beq`, `bne`，这些是最基础也最常用的。
2. **理解每条指令的功能**：不要死记硬背，理解每条指令到底在做什么。例如，`add` 就是将两个寄存器的值相加，`lw` 是从内存加载数据。
3. **多做练习**：通过编写简单的小程序，不断加深对这些指令的理解。每做一次练习，你对指令的记忆就会更加深刻。
4. **用类比的方法**：可以**将寄存器想象成“盒子”**，每个盒子里存放一个数字，指令就是用来操控这些盒子中的数字。比如，`add` 就是把两个盒子里的数字相加，`sw` 是把盒子里的数字放到内存中。

------

### 简单总结：

- **寄存器**：存储数据的地方。
- **常用指令**：`add`, `sub`, `lw`, `sw`, `beq`, `bne`。
- **跳转指令**：`jal`, `jr`，用于函数调用和返回。
- **移位指令**：`sll`, `srl`，用于位移操作。



## 部分详解

### `lw` 指令概述

#### 基本概念

`lw` 是 MIPS 汇编中的 **加载字**（**load word**）指令，它的作用是从内存中加载 **32 位（4 字节）**的数据，并把它放入一个寄存器中。

指令格式：

```scss
lw  寄存器目标, 偏移量(基地址寄存器)
```

- **寄存器目标**：这是你要把数据加载到的寄存器，在你的例子中是 `$t0`。
- **偏移量**：内存地址偏移量，通常是一个立即数，表示**从基地址开始的偏移字节数。**若是 `0`，就没有偏移。
- **基地址寄存器**：这是一个存放内存基地址的寄存器。

#### 例子

例如：`lw $t0, 0($t1)` 具体含义：

- **`$t0`**：表示目标寄存器，加载的数据将存放到 `$t0` 中。
- **`0`**：这是偏移量，表示**从基地址开始的偏移字节数**。在这里偏移量为 `0`，即**直接从 `$t1` 中的地址**加载数据。
- **`$t1`**：这是基地址寄存器，表示你要从内存的哪个地址开始加载数据。`$t1` 中**存放**的是一个**内存地址**。

**`lw $t0, 0($t1)`** 的意思就是：从 **`$t1` 寄存器所指向的内存地址** 开始，加载 **4 字节** 的数据到 **`$t0` 寄存器**。

再举个例子：

假设：

- `$t1 = 1000`（即 `$t1` 寄存器的值是 `1000`，代表内存地址 `1000`）。
- 内存地址 `1000` 处存储的 4 字节数据是 `0xAABBCCDD`。

那么执行 `lw $t0, 0($t1)` 时：

1. 从内存地址 `1000` 读取 4 字节数据，即 `0xAABBCCDD`。
2. 把 `0xAABBCCDD` 存储到 `$t0` 寄存器中。
3. 执行完之后，**`$t0`** 存储的值变为 `0xAABBCCDD`。

如果偏移量不为 0，比如 `lw $t0, 4($t1)`：

- `$t1` 还是 `1000`，但偏移量变为 `4`，这意味着你从内存地址 `1000 + 4 = 1004` 开始读取数据。

假设：

- 内存地址 `1004` 处存放的数据是 `0x11223344`。
- 执行 `lw $t0, 4($t1)` 时，会从内存地址 `1004` 读取 4 字节数据，并存储到 `$t0` 中。

最终，**`$t0`** 的值将变为 `0x11223344`。

那么， `lw $t0, 1($t1)`值是多少？

它会从**非对齐**的内存地址开始读取数据。虽然 MIPS 汇编确实希望 **内存访问是对齐的**（即从 **4 字节的倍数**地址开始读取），但并不是所有情况都要求如此严格。

#### 内存对齐与非对齐

首先，我们来讲讲**内存对齐原则**：

在 MIPS 汇编中，**`lw`（加载字）指令** 通常会从 **对齐的地址** 开始加载数据，对齐的意思是：

- 地址是 **4 的倍数**，如 `0x1000`, `0x1004`, `0x1008` 等等。
- 这是因为 **MIPS 使用 32 位字长**，而 32 位的数据就是 4 字节，4 的倍数地址**正好是每个字存储的起始位置**。

但是，可以不对齐，比如 `lw $t0, 1($t1)`。

如果你有这样的指令 `lw $t0, 1($t1)`，并且 `$t1 = 0x1000`（也即是基址的位置），这条指令意味着要从 **地址 `0x1001`** 开始加载 4 个字节。虽然内存仍然可以加载 4 个字节，但这次 **读取的数据可能跨越多个地址块**，因为它是从非对齐地址开始读取的。在此之前，我们说一下小端存储。

#### 小端存储

在 **小端存储模式** 中，**最低有效字节**（Least Significant Byte, LSB）存储在**最低地址**，而**最高有效字节**（Most Significant Byte, MSB）存储在**最高地址**。也就是说，数字**从低位到高位依次存储在内存中**。

举例：假设我们要存储 32 位的数 `0xAABBCCDD`，在小端存储模式下，它在内存中的存储顺序如下：

| 地址     | 数据（字节） |
| :------- | ------------ |
| `0x1000` | `0xDD`       |
| `0x1001` | `0xCC`       |
| `0x1002` | `0xBB`       |
| `0x1003` | `0xAA`       |

在这个例子中，地址 `0x1000` 存储的是最小的字节 `0xDD`，地址 `0x1003` 存储的是最大的字节 `0xAA`。

回到 `lw $t0, 1($t1)`。按照 **小端存储模式** 的顺序排列，如果 `$t1` 寄存器的值是 `0x1000`，那么指令 **`lw $t0, 0($t1)`** 的意思是从内存地址 `0x1000` 开始，读取 4 个字节，并将它们存入寄存器 `$t0` 中。

- 内存内容 从地址  `0x1000` 开始：
  - `0x1000` 处的值是 `0xDD`。
  - `0x1001` 处的值是 `0xCC`。
  - `0x1002` 处的值是 `0xBB`。
  - `0x1003` 处的值是 `0xAA`。

这 4 个字节被读取后，，终存入 `$t0` 的值为：

- **`$t0 = 0xAABBCCDD`**

假设内存地址 `1004` 起按照 **小端存储** 的规则存放的数据是 `0x11223344`。按照 **小端存储** 的规则， `lw $t0, 1($t1)= 0x44AABBCC`。

#### 总结：

- **`lw`**：从内存中加载 4 字节数据。
- **`$t0`**：目标寄存器，数据加载到这里。
- **`0($t1)`**：从 `$t1` 寄存器所指向的内存地址 `0` 偏移量（即 `$t1` 所指向的地址）开始加载。

**`lw $t0, 0($t1)`** 的完整意思就是：从 `$t1` 中存放的地址处加载 4 字节的数据，并将其存入 `$t0` 中。